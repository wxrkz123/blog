<?xml version="1.0" encoding="utf-8"?>
<search> 
  
  
    
    <entry>
      <title>C implements data structures</title>
      <link href="/blog/2023/09/12/C-implements-data-structures/"/>
      <url>/blog/2023/09/12/C-implements-data-structures/</url>
      
        <content type="html"><![CDATA[<h2 id="1-1-c语言实现linked-list"><a href="#1-1-c语言实现linked-list" class="headerlink" title="1-1.c语言实现linked_list"></a>1-1.c语言实现linked_list</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Definition of the linked_list structure.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">linked_list</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data;</span><br><span class="line">    <span class="class"><span class="keyword">struct</span> <span class="title">linked_list</span> *<span class="title">next</span>;</span></span><br><span class="line">&#125;linked_list;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to create a new linked_list.</span></span><br><span class="line">linked_list *<span class="title function_">create_linked_list</span><span class="params">(<span class="type">int</span> data)</span> &#123;</span><br><span class="line">    linked_list *new_linked_list = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(linked_list));</span><br><span class="line">    new_linked_list-&gt;data = data;</span><br><span class="line">    new_linked_list-&gt;next = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">return</span> new_linked_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to insert a new linked_list at the beginning of the list.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_at_begin</span><span class="params">(linked_list **head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    linked_list *new_linked_list = create_linked_list(data);</span><br><span class="line">    new_linked_list-&gt;next = *head;</span><br><span class="line">    *head = new_linked_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to insert a new linked_list at the end of the list.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">insert_at_end</span><span class="params">(linked_list **head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    linked_list *new_linked_list = create_linked_list(data);</span><br><span class="line">    <span class="keyword">if</span> (*head == <span class="literal">NULL</span>) &#123;</span><br><span class="line">        *head = new_linked_list;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    linked_list *current = *head;</span><br><span class="line">    <span class="keyword">while</span> (current-&gt;next != <span class="literal">NULL</span>)&#123;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    current-&gt;next = new_linked_list;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to delete a new_linked_list from the list.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_linked_list</span><span class="params">(linked_list **head, <span class="type">int</span> data)</span> &#123;</span><br><span class="line">    linked_list *current = *head;</span><br><span class="line">    linked_list *previous = <span class="literal">NULL</span>;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>) &#123;</span><br><span class="line">        <span class="keyword">if</span> (current-&gt;data == data)</span><br><span class="line">        &#123;</span><br><span class="line">            <span class="keyword">if</span> (previous == <span class="literal">NULL</span>) &#123;</span><br><span class="line">                *head = current-&gt;next;</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                previous-&gt;next = current-&gt;next;</span><br><span class="line">            &#125;</span><br><span class="line">            <span class="built_in">free</span>(current);</span><br><span class="line">            <span class="keyword">return</span> ;</span><br><span class="line">        &#125;</span><br><span class="line">        previous = current;</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Function to print the list.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">print_list</span><span class="params">(linked_list *head)</span> &#123;</span><br><span class="line">    linked_list *current = head;</span><br><span class="line">    <span class="keyword">while</span> (current != <span class="literal">NULL</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;%d&quot;</span>,current-&gt;data);</span><br><span class="line">        current = current-&gt;next;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;\n&quot;</span>);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//main</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> <span class="type">const</span> *argv[])</span>&#123;</span><br><span class="line">    linked_list *head = <span class="literal">NULL</span>;</span><br><span class="line"></span><br><span class="line">    insert_at_begin(&amp;head,<span class="number">1</span>);</span><br><span class="line">    insert_at_begin(&amp;head,<span class="number">2</span>);</span><br><span class="line">    insert_at_begin(&amp;head,<span class="number">3</span>);</span><br><span class="line"></span><br><span class="line">    insert_at_end(&amp;head,<span class="number">4</span>);</span><br><span class="line">    insert_at_end(&amp;head,<span class="number">5</span>);</span><br><span class="line"></span><br><span class="line">    print_list(head);</span><br><span class="line"></span><br><span class="line">    delete_linked_list(&amp;head,<span class="number">4</span>);</span><br><span class="line"></span><br><span class="line">    print_list(head);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-2-c语言实现dynamic-array"><a href="#1-2-c语言实现dynamic-array" class="headerlink" title="1-2.c语言实现dynamic_array"></a>1-2.c语言实现dynamic_array</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="comment">// Define a dynamic array structure that stores an array and its size.</span></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> &#123;</span></span><br><span class="line">    <span class="type">int</span>* <span class="built_in">array</span>;</span><br><span class="line">    <span class="type">size_t</span> size;</span><br><span class="line">&#125; dynamic_array;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fuction to create a new dynamic array.</span></span><br><span class="line">dynamic_array* <span class="title function_">create_array</span> <span class="params">(<span class="type">size_t</span> size)</span> &#123;</span><br><span class="line">    dynamic_array* arr = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(dynamic_array));</span><br><span class="line">    arr-&gt;<span class="built_in">array</span> = <span class="built_in">malloc</span>(size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line">    arr-&gt;size = size;</span><br><span class="line">    <span class="keyword">return</span> arr; </span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fuction to read an element from dynamic array.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">read_array</span><span class="params">(dynamic_array* arr,<span class="type">size_t</span> index)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;arr-&gt;size) &#123;</span><br><span class="line">        <span class="keyword">return</span> arr-&gt;<span class="built_in">array</span>[index];</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error : index out of bounds: %d\n&quot;</span>,index);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;    </span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fuction to update an element from a dynamic array.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">update_array</span><span class="params">(dynamic_array* arr, <span class="type">size_t</span> index, <span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span>(index&lt;arr-&gt;size) &#123;</span><br><span class="line">        arr-&gt;<span class="built_in">array</span>[index] = value;</span><br><span class="line">    &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error : index out of bounds: %d\n&quot;</span>,index);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// Fuction to delete a dynamic array.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">delete_array</span><span class="params">(dynamic_array* arr)</span> &#123;</span><br><span class="line">    <span class="built_in">free</span>(arr-&gt;<span class="built_in">array</span>);</span><br><span class="line">    <span class="built_in">free</span>(arr);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main </span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    <span class="comment">// Create a new dynamic array</span></span><br><span class="line">    dynamic_array* arr = create_array(<span class="number">10</span>);</span><br><span class="line"></span><br><span class="line">    update_array(arr,<span class="number">5</span>,<span class="number">100000</span>);</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> value = read_array(arr,<span class="number">5</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;The value is : %d\n&quot;</span>, value);</span><br><span class="line"></span><br><span class="line">    delete_array(arr);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-3-c语言实现hash"><a href="#1-3-c语言实现hash" class="headerlink" title="1-3 c语言实现hash"></a>1-3 c语言实现hash</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br><span class="line">66</span><br><span class="line">67</span><br><span class="line">68</span><br><span class="line">69</span><br><span class="line">70</span><br><span class="line">71</span><br><span class="line">72</span><br><span class="line">73</span><br><span class="line">74</span><br><span class="line">75</span><br><span class="line">76</span><br><span class="line">77</span><br><span class="line">78</span><br><span class="line">79</span><br><span class="line">80</span><br><span class="line">81</span><br><span class="line">82</span><br><span class="line">83</span><br><span class="line">84</span><br><span class="line">85</span><br><span class="line">86</span><br><span class="line">87</span><br><span class="line">88</span><br><span class="line">89</span><br><span class="line">90</span><br><span class="line">91</span><br><span class="line">92</span><br><span class="line">93</span><br><span class="line">94</span><br><span class="line">95</span><br><span class="line">96</span><br><span class="line">97</span><br><span class="line">98</span><br><span class="line">99</span><br><span class="line">100</span><br><span class="line">101</span><br><span class="line">102</span><br><span class="line">103</span><br><span class="line">104</span><br><span class="line">105</span><br><span class="line">106</span><br><span class="line">107</span><br><span class="line">108</span><br><span class="line">109</span><br><span class="line">110</span><br><span class="line">111</span><br><span class="line">112</span><br><span class="line">113</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;string.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> TABLE_SIZE 10</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> <span class="title">hash_table</span></span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> size;</span><br><span class="line">    <span class="type">int</span> num_elements;</span><br><span class="line">    <span class="type">char</span>** keys;</span><br><span class="line">    <span class="type">int</span>* values;</span><br><span class="line">&#125; HashTable;</span><br><span class="line"></span><br><span class="line">HashTable* <span class="title function_">init_table</span><span class="params">()</span> &#123;</span><br><span class="line">    HashTable* table = <span class="built_in">malloc</span>(<span class="keyword">sizeof</span>(HashTable));</span><br><span class="line">    table-&gt;size = TABLE_SIZE;</span><br><span class="line">    table-&gt;num_elements = <span class="number">0</span>;</span><br><span class="line">    table-&gt;keys = <span class="built_in">malloc</span>(table-&gt;size * <span class="keyword">sizeof</span>(<span class="type">char</span>*));</span><br><span class="line">    table-&gt;values = <span class="built_in">malloc</span>(table-&gt;size * <span class="keyword">sizeof</span>(<span class="type">int</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">for</span> (<span class="type">int</span> i = <span class="number">0</span>; i &lt; table-&gt;size; i++)</span><br><span class="line">    &#123;</span><br><span class="line">        table-&gt;keys[i] = <span class="literal">NULL</span>;</span><br><span class="line">        table-&gt;values[i] = <span class="number">0</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns the hash code for the given key.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">hash</span><span class="params">(<span class="type">char</span>* key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> hash = <span class="number">0</span>;</span><br><span class="line">    <span class="keyword">for</span>(<span class="type">int</span> i = <span class="number">0</span>; i &lt; <span class="built_in">strlen</span>(key); i++) &#123;</span><br><span class="line">        hash = (hash + key[i]) % TABLE_SIZE;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> hash;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">//insert the hash code for the given key.</span></span><br><span class="line"><span class="type">void</span> <span class="title function_">put</span><span class="params">(HashTable* table,<span class="type">char</span>* key,<span class="type">int</span> value)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hash(key);</span><br><span class="line"></span><br><span class="line">    <span class="keyword">while</span> (table-&gt;keys[index] != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(table-&gt;keys[index],key) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        index = (index + <span class="number">1</span>) % table-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(table-&gt;values[index] != <span class="number">0</span>)&#123;</span><br><span class="line">        table-&gt;num_elements++;</span><br><span class="line">    &#125;</span><br><span class="line">    table-&gt;keys[index] = key;</span><br><span class="line">    table-&gt;values[index] = value;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">get</span><span class="params">(HashTable* table,<span class="type">char</span>* key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hash(key);</span><br><span class="line">    <span class="keyword">while</span> (table-&gt;keys[index] != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(table-&gt;keys[index],key) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        index = (index + <span class="number">1</span>) % table-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(table-&gt;keys[index] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> table-&gt;values[index];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">remove_key</span><span class="params">(HashTable *table,<span class="type">char</span> *key)</span> &#123;</span><br><span class="line">    <span class="type">int</span> index = hash(key);</span><br><span class="line">    <span class="keyword">while</span> (table-&gt;keys[index] != <span class="literal">NULL</span> &amp;&amp; <span class="built_in">strcmp</span>(table-&gt;keys[index],key) != <span class="number">0</span>)</span><br><span class="line">    &#123;</span><br><span class="line">        index = (index + <span class="number">1</span>) % table-&gt;size;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">if</span>(table-&gt;keys[index] == <span class="literal">NULL</span>)&#123;</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line">    table-&gt;keys[index] = <span class="literal">NULL</span>;</span><br><span class="line">    table-&gt;values[index] = <span class="number">0</span>;</span><br><span class="line">    table-&gt;num_elements--;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns the load factor for the hash table.</span></span><br><span class="line"><span class="type">float</span> <span class="title function_">load_factor</span><span class="params">(HashTable* table)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> (<span class="type">float</span>)table-&gt;num_elements / (<span class="type">float</span>)table-&gt;size;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// returns the number of the elements in the hash table.</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">num_elements</span><span class="params">(HashTable* table)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> table-&gt;num_elements;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// This main function first initializes a new hash table and then inserts three key-value pairs. It outputs the number of elements and load factor of the hash table, and then gets and prints the value of each key. Next, it removes a key from the hash table, then outputs the number of elements and load factor of the hash table again, and finally gets and prints the value of the deleted key (which should be -1 because the key has been deleted).</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">()</span> &#123;</span><br><span class="line">    HashTable* table = init_table();</span><br><span class="line"></span><br><span class="line">    put(table, <span class="string">&quot;key1&quot;</span>, <span class="number">10</span>);</span><br><span class="line">    put(table, <span class="string">&quot;key2&quot;</span>, <span class="number">20</span>);</span><br><span class="line">    put(table, <span class="string">&quot;key3&quot;</span>, <span class="number">30</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of elements: %d\n&quot;</span>, num_elements(table));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Load factor: %.2f\n&quot;</span>, load_factor(table));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of key1: %d\n&quot;</span>, get(table, <span class="string">&quot;key1&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of key2: %d\n&quot;</span>, get(table, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of key3: %d\n&quot;</span>, get(table, <span class="string">&quot;key3&quot;</span>));</span><br><span class="line"></span><br><span class="line">    remove_key(table, <span class="string">&quot;key2&quot;</span>);</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Number of elements after removing a key: %d\n&quot;</span>, num_elements(table));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Load factor after removing a key: %.2f\n&quot;</span>, load_factor(table));</span><br><span class="line"></span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;Value of key2 after removing it: %d\n&quot;</span>, get(table, <span class="string">&quot;key2&quot;</span>));</span><br><span class="line"></span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h2 id="1-4-c语言实现stack"><a href="#1-4-c语言实现stack" class="headerlink" title="1-4 c语言实现stack"></a>1-4 c语言实现stack</h2><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br><span class="line">43</span><br><span class="line">44</span><br><span class="line">45</span><br><span class="line">46</span><br><span class="line">47</span><br><span class="line">48</span><br><span class="line">49</span><br><span class="line">50</span><br><span class="line">51</span><br><span class="line">52</span><br><span class="line">53</span><br><span class="line">54</span><br><span class="line">55</span><br><span class="line">56</span><br><span class="line">57</span><br><span class="line">58</span><br><span class="line">59</span><br><span class="line">60</span><br><span class="line">61</span><br><span class="line">62</span><br><span class="line">63</span><br><span class="line">64</span><br><span class="line">65</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdio.h&gt;</span></span></span><br><span class="line"><span class="meta">#<span class="keyword">include</span> <span class="string">&lt;stdlib.h&gt;</span></span></span><br><span class="line"></span><br><span class="line"><span class="meta">#<span class="keyword">define</span> STACK_SIZE 100</span></span><br><span class="line"></span><br><span class="line"><span class="keyword">typedef</span> <span class="class"><span class="keyword">struct</span> </span></span><br><span class="line"><span class="class">&#123;</span></span><br><span class="line">    <span class="type">int</span> data[STACK_SIZE];</span><br><span class="line">    <span class="type">int</span> top;</span><br><span class="line">&#125; Stack;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">init_stack</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top = <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_empty</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == <span class="number">-1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">is_full</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;top == STACK_SIZE - <span class="number">1</span>;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">void</span> <span class="title function_">push</span><span class="params">(Stack *<span class="built_in">stack</span>,<span class="type">int</span> x)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_full(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Stack is full\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> ;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="built_in">stack</span>-&gt;top++;</span><br><span class="line">    <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top] = x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">pop</span><span class="params">(Stack *<span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="type">int</span> x = <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">    <span class="built_in">stack</span>-&gt;top--;</span><br><span class="line">    <span class="keyword">return</span> x;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="type">int</span> <span class="title function_">peek</span><span class="params">(Stack* <span class="built_in">stack</span>)</span> &#123;</span><br><span class="line">    <span class="keyword">if</span> (is_empty(<span class="built_in">stack</span>)) &#123;</span><br><span class="line">        <span class="built_in">printf</span>(<span class="string">&quot;Error: Stack is empty\n&quot;</span>);</span><br><span class="line">        <span class="keyword">return</span> <span class="number">-1</span>;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">return</span> <span class="built_in">stack</span>-&gt;data[<span class="built_in">stack</span>-&gt;top];</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="comment">// main</span></span><br><span class="line"><span class="type">int</span> <span class="title function_">main</span><span class="params">(<span class="type">int</span> argc,<span class="type">char</span> <span class="type">const</span> *argv[])</span> &#123;</span><br><span class="line">    Stack s;</span><br><span class="line">    init_stack(&amp;s);</span><br><span class="line">    push(&amp;s,<span class="number">1</span>);</span><br><span class="line">    push(&amp;s,<span class="number">2</span>);</span><br><span class="line">    push(&amp;s,<span class="number">3</span>);</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,pop(&amp;s));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,peek(&amp;s));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,is_empty(&amp;s));</span><br><span class="line">    <span class="built_in">printf</span>(<span class="string">&quot;%d\n&quot;</span>,is_full(&amp;s));</span><br><span class="line">    <span class="keyword">return</span> <span class="number">0</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> program </tag>
            
            <tag> data Structure and alagorithm </tag>
            
            <tag> computer0 </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Java Base</title>
      <link href="/blog/2023/09/06/Java-Base/"/>
      <url>/blog/2023/09/06/Java-Base/</url>
      
        <content type="html"><![CDATA[<h1 id="认识Java"><a href="#认识Java" class="headerlink" title="认识Java"></a>认识Java</h1><h1 id="0-前言"><a href="#0-前言" class="headerlink" title="0.前言"></a>0.前言</h1><p>学Java前需要学C，至少学到结构体，C语言课程是基础。</p><p>指针、算法、数据结构不好也没关系，这篇文章主要是介绍基础，对c语言的要求不算很高。</p><p>另外，本文章用的java编译器是Intellij IDEA，版本是2021.1.1。<img src="../Java-Base/Intellij-IDEA.png" alt="Intellij IDEA"></p><h1 id="0-0-java-idea安装"><a href="#0-0-java-idea安装" class="headerlink" title="0.0 java idea安装"></a>0.0 java idea安装</h1><p>Java SE 9 安装下载路径：<a href="http://www.oracle.com/java/technologies/javase/javase9-archive-downloads.html">http://www.oracle.com/java/technologies/javase/javase9-archive-downloads.html</a></p><p>JDK安装方法：</p><blockquote><p><code>新建系统变量：</code><br>JAVA_HOME（路径取jdk绝对路径）<br><code>在系统变量Path后面追加：</code><br>%JAVA_HOME%\bin<br>%JAVA_HOME%\jre\bin<br><code>添加classpath：</code><br>CLASSPATH<br>.<br>%JAVA_HOME%\lib\dt.jar<br>%JAVA_HOME%\lib\tools.jar<br><code>验证：</code><br>cmd控制台代码：javac -version<br>IDE:Interllij IDEA;JetBrains<br>(注意：mac苹果电脑下载dmg文件。Windows下载exe文件)</p></blockquote><h1 id="0-1-Java的执行过程"><a href="#0-1-Java的执行过程" class="headerlink" title="0-1 Java的执行过程"></a>0-1 Java的执行过程</h1><p>对比Java与C构建模式</p><table><thead><tr><th>JAVA</th><th>C</th></tr></thead><tbody><tr><td>java执行时会生成<code>.class</code>文件</td><td>C执行的时候会生成<code>.exe</code>文件（win）</td></tr><tr><td>java要运行必须有jdk、jre和jvm</td><td>C执行的时候不需要这些文件</td></tr><tr><td>java<code>.class</code>跨平台效果好</td><td>C<code>.exe</code>跨平台效果不好（win）</td></tr></tbody></table><ul><li><strong>jdk(Java Development Kit)：</strong> java程序开发工具包</li><li><strong>jre(Java runtime environment)：</strong> java运行环境</li><li><strong>jvm(Java Virtual Machine)：</strong> java虚拟机</li></ul><p>console代码</p><table><thead><tr><th align="center">代码</th><th align="center">注释</th></tr></thead><tbody><tr><td align="center">javac 文件名.java</td><td align="center">将java文件编译成class文件</td></tr><tr><td align="center">java 文件名</td><td align="center">运行java文件（必须是class文件）</td></tr><tr><td align="center">java 文件名.java</td><td align="center">运行java文件</td></tr></tbody></table><p>注意：class文件又称字节码文件</p><h1 id="0-2-package"><a href="#0-2-package" class="headerlink" title="0-2 package"></a>0-2 package</h1><p><code>Java package</code> 如同文件夹一样，工程文件主要分为<code>idea</code>、<code>out</code>、<code>src</code>、<code>web</code>四个大包</p><p><strong>1.idea文件夹</strong></p><ul><li><code>.idea</code>存放项目的配置信息，包括历史记录，版本控制信息等</li></ul><p><strong>2.iml文件夹</strong></p><ul><li><code>iml</code>(infomation of module)是IntelliJ IDEA 自动创建的模块文件</li><li>用于Java应用开发，存储一些模块开发相关的信息，还可能会存储一 些模块路径信息， 依赖信息以及别的一些设置</li></ul><p><strong>3.src文件夹</strong></p><ul><li>即<code>source</code>，存放的是项目的源文件(.java后缀与配置文件)</li><li>分成几个包的目的：对代码的优化、实现高聚合、低耦合特点、便于以后的扩展和更改</li></ul><p><strong>4.External Libraries</strong></p><ul><li>Java外部库</li></ul><p><strong>5.Scratches and Consoles</strong></p><ul><li>Intellij IDEA 提供了两种临时的文件编辑环境，两种 Scratches 分别是<code>Scratch files</code> 和 <code>Scratch buffers</code></li></ul><blockquote><p>Scratch files ：Scratch files 有着完整的运行和 debug 功能等等，这些文件需要指定编程语言类型并且指定后缀。<br>Scratch buffers : Scratch buffers仅仅是为了简单的编辑记录，所以不需要指定编程语言并且指定后缀，默认文件类型是 .txt。需要注意的是，Scratch buffers最多只能创建 5 个，超过 5 个将开始重用以前的，并且以前文件的内容会被重置。</p></blockquote><p><strong>6.项目视图</strong><br>默认是将<code>package</code>层级以简洁显示的,非精简模式</p><p><img src="../Java-Base/%E7%AE%80%E6%B4%81%E6%A8%A1%E5%BC%8F.png" alt="简洁模式"><br>对<code>packages</code>单击右键，点击<code>Compact Middle Packages</code>即可切换成精简模式</p><p><img src="../Java-Base/%E7%B2%BE%E7%AE%80%E6%A8%A1%E5%BC%8F.png" alt="精简模式"><br><img src="../Java-Base/%E7%B2%BE%E7%AE%80%E6%A8%A1%E5%BC%8F%E7%A4%BA%E4%BE%8B.png" alt="精简模式示例"></p><h1 id="0-3-第一个程序的讲解"><a href="#0-3-第一个程序的讲解" class="headerlink" title="0-3 第一个程序的讲解"></a>0-3 第一个程序的讲解</h1><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.microsoft.demo; <span class="comment">//定位你的Java代码放在src文件夹下的位置</span></span><br><span class="line"></span><br><span class="line"><span class="comment">//公共的  类   类名（开头字母必须大写和文件名相同）</span></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Main</span>&#123; </span><br><span class="line">    </span><br><span class="line">    <span class="comment">//mian函数的固定格式</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span>&#123;</span><br><span class="line">        </span><br><span class="line">        <span class="comment">//语句</span></span><br><span class="line">        System.out.println(<span class="string">&quot;Hello&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">    <span class="comment">//java函数</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span><span class="params">(<span class="type">int</span> number_a,<span class="type">int</span> number_b)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> number_a+number_</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//函数的调用和C是一样的</span></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>ctrl+alt+v</code> 在调用函数的时候自动生成变量</p><p><code>.soutv</code> 打印最靠近的变量，也可以是你自己选定的变量</p><h1 id="0-4-注释和文档"><a href="#0-4-注释和文档" class="headerlink" title="0-4 注释和文档"></a>0-4 注释和文档</h1><p><strong>1.基本注释</strong></p><ul><li>和C语言一样有单行注释和段落注释</li><li>单行注释 <code>// ……</code></li><li>多行注释 <code>/* ...... */</code> 注释内容不会出现在javadoc 生成的文档中</li></ul><p><strong>2.方法注释和类注释</strong></p><ul><li>即文档注释 : <code>/** ...... */</code> 注释内容写入javadoc生成的文档</li><li>注释格式<code>/** ...... */</code>里面的内容有介绍函数，还有方法中用到的参数和返回值</li><li>这个可以快速生成一个方法文档（想要生成文档可以在快捷键里查doc）</li><li>IntelliJ IDEA 里查看一个函数注释的方法是 <code>ctrl+q</code></li></ul><h1 id="0-5-字符串演示"><a href="#0-5-字符串演示" class="headerlink" title="0-5 字符串演示"></a>0-5 字符串演示</h1><p><strong>C语言如何定义字符串?</strong></p><figure class="highlight c"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">char</span> data[<span class="number">3</span>] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> data[] = &#123;<span class="string">&#x27;a&#x27;</span>, <span class="string">&#x27;b&#x27;</span>, <span class="string">&#x27;c&#x27;</span>, <span class="string">&#x27;\0&#x27;</span>&#125;;</span><br><span class="line"><span class="type">char</span> data[] = <span class="string">&quot;abc&quot;</span>;</span><br></pre></td></tr></table></figure><p><strong>Java如何定义字符串?</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">String</span> <span class="variable">s1</span> <span class="operator">=</span> <span class="string">&quot;Hello World!&quot;</span>;                 </span><br><span class="line"><span class="type">String</span> <span class="variable">s2</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">String</span>(<span class="string">&quot;Hello World!&quot;</span>);</span><br></pre></td></tr></table></figure><ul><li><code>String</code>是java中定义字符串的类，方便快捷，使用面向对象的方式还有很多骚操作</li><li>获取字符串长度：<code>字符串名.length()</code></li><li>使用<code>.concat()</code>连接字符串</li><li>使用<code>+</code>连接字符串</li></ul><h1 id="0-6-字符串结束符"><a href="#0-6-字符串结束符" class="headerlink" title="0-6 字符串结束符"></a>0-6 字符串结束符</h1><p><strong>C语言种的字符串是怎样的？</strong></p><ul><li>C语言中没有专门的字符串变量，通常用一个字符数组来存放一个字符串</li><li>字符串本质上就是以<code>&#39;\0&#39;</code>作为结尾的特殊字符数组</li><li>因此当把一个字符串存入一个数组时，也把结束符 <code>&#39;\0&#39;</code>存入数组，并以此作为该字符串是否结束的标志</li></ul><p><strong>为什么Java里没有&#x2F;0？</strong></p><ul><li>严格控制字符串，防止内存泄漏</li><li>这是Java为了保护程序以及开发者友好，强制并自动为我们加了<code>&#39;\0&#39;</code></li></ul><h1 id="0-7-自动类型"><a href="#0-7-自动类型" class="headerlink" title="0-7 自动类型"></a>0-7 自动类型</h1><p><strong>自动类型转换</strong></p><ul><li>整型、实型（常量）、字符型数据可以混合运算</li><li>运算中，不同类型的数据先转化为同一类型，然后进行运算</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">低  ------------------------------------&gt;  高</span><br><span class="line"><span class="type">byte</span>,<span class="type">short</span>,<span class="type">char</span>—&gt; <span class="type">int</span> —&gt; <span class="type">long</span>—&gt; <span class="type">float</span> —&gt; <span class="type">double</span> </span><br></pre></td></tr></table></figure><h1 id="0-8-import导包和API文档"><a href="#0-8-import导包和API文档" class="headerlink" title="0-8 import导包和API文档"></a>0-8 import导包和API文档</h1><blockquote><ul><li><code>import</code>和C中的<code>#include</code>一样，导入一些自带的方法</li><li>有一些包中的函数是不需要导入的，使用同一个<code>package</code>下的包不需要<code>import</code></li><li><code>java.lang.*</code>是java默认自带的</li></ul></blockquote><p>java文档中常用的包</p><table><thead><tr><th align="center">包名</th><th align="center">用途</th></tr></thead><tbody><tr><td align="center">java.io</td><td align="center">通过数据流，序列化和文件系统提供输入和输出</td></tr><tr><td align="center">java.lang</td><td align="center">提供利用Java语言设计的基础类</td></tr><tr><td align="center">java.math</td><td align="center">提供进行算法的类</td></tr><tr><td align="center">java.text</td><td align="center">处理文本、日期、数字和消息类和接口</td></tr><tr><td align="center">java.util</td><td align="center">各种实用的工具类</td></tr></tbody></table><p>java 9 document文档网址：<a href="http://docs.oralce.com/javase/9/docs/api/index.html?overview-summerary.html">http://docs.oralce.com/javase/9/docs/api/index.html?overview-summerary.html</a></p><h1 id="0-9-Java中的数组"><a href="#0-9-Java中的数组" class="headerlink" title="0-9 Java中的数组"></a>0-9 Java中的数组</h1><p>对比C和Java静态数组定义方式</p><table><thead><tr><th>定义方式</th><th>Java</th><th>C</th></tr></thead><tbody><tr><td>初始化法</td><td><code>int[ ] arr =&#123;1,2,3&#125;</code></td><td><code>int arr [] = &#123;1,2,3&#125;</code></td></tr><tr><td>分配空间法</td><td><code>Type[] arr=new Type[size]</code></td><td><code>int arr[size]</code></td></tr></tbody></table><p>普通的静态数组有缺陷：长度是固定的，不能扩容，没有灵活性</p><p>注意： <strong><code>String</code>的length带括号，数组里的length不带括号</strong></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">str.length();</span><br><span class="line">arr.length;</span><br></pre></td></tr></table></figure><p>增强for循环</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">for</span> (<span class="type">int</span> i: arr_2) &#123;</span><br><span class="line">     System.out.println(arr_2[i]);</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">for</span>(<span class="type">double</span> element:myList)&#123;</span><br><span class="line">System.out.println(element);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="0-10-Arrays"><a href="#0-10-Arrays" class="headerlink" title="0-10 Arrays"></a>0-10 Arrays</h1><p>提供方法对数组进行操作</p><p>例如：排序<code>sort()</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr_1 = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">6</span>, <span class="number">7</span>, <span class="number">8</span>,<span class="number">111</span>,<span class="number">1111</span>,<span class="number">112</span>,<span class="number">1235</span>,<span class="number">123</span>&#125;;</span><br><span class="line">        Arrays.sort(arr_1);</span><br><span class="line">        <span class="keyword">for</span> (<span class="type">int</span> element:arr_1) &#123;</span><br><span class="line">            System.out.print(element + <span class="string">&quot; &quot;</span>);</span><br><span class="line">        &#125;</span><br></pre></td></tr></table></figure><p>例如：二分查找 <code>Arrays.binarySearch(arr_1,6)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span> <span class="variable">result_index</span> <span class="operator">=</span> Arrays.binarySearch(arr_1,<span class="number">6</span>);</span><br><span class="line">      System.out.println(<span class="string">&quot;result_index = &quot;</span> + result_index);</span><br></pre></td></tr></table></figure><p>相同顺序下，数组是否相等<code>Arrays.equals(arr_1, arr_2)</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">int</span>[] arr_1 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">     <span class="type">int</span>[] arr_2 = &#123;<span class="number">1</span>,<span class="number">2</span>,<span class="number">3</span>&#125;;</span><br><span class="line">     <span class="type">boolean</span> <span class="variable">b</span> <span class="operator">=</span> Arrays.equals(arr_1, arr_2);</span><br><span class="line">     System.out.println(<span class="string">&quot;b = &quot;</span> + b);</span><br></pre></td></tr></table></figure><h1 id="0-11-函数和方法"><a href="#0-11-函数和方法" class="headerlink" title="0-11 函数和方法"></a>0-11 函数和方法</h1><p><strong>什么是方法?</strong></p><ul><li>Java方法是语句的集合，它们在一起执行一个功能</li><li>方法和C里的函数是一模一样的</li></ul><blockquote><p><strong>参考：</strong></p><ul><li><strong><a href="https://www.runoob.com/java/java-methods.html?_t_t_t=0.9364758810464391">Java 方法-菜鸟教程</a></strong></li></ul></blockquote><h1 id="0-12-方法的重载"><a href="#0-12-方法的重载" class="headerlink" title="0-12 方法的重载"></a>0-12 方法的重载</h1><p>方法名相同，参数个数或者参数类型不同</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">package</span> com.microsoft.demo;</span><br><span class="line"><span class="keyword">import</span> java.util.Arrays;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">int</span> <span class="variable">sum</span> <span class="operator">=</span> sum(<span class="number">1</span>, <span class="number">2</span>);</span><br><span class="line">        <span class="type">double</span> <span class="variable">value</span> <span class="operator">=</span> sum(<span class="number">1.2</span> , <span class="number">3.4</span>);</span><br><span class="line">        System.out.println(<span class="string">&quot;sum = &quot;</span> + sum);</span><br><span class="line">        System.out.println(<span class="string">&quot;value = &quot;</span> + value);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">int</span> <span class="title function_">sum</span> <span class="params">(<span class="type">int</span> x, <span class="type">int</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="type">double</span> <span class="title function_">sum</span> <span class="params">( <span class="type">double</span> x, <span class="type">double</span> y)</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> x + y;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>好了，引导部分到此结束，下面就是java语言面向对象的部分，这些内容也算是基于我学习java过程中的总结与整合而来的笔记，希望对大家有帮助。</p><h1 id="OOP上半部分"><a href="#OOP上半部分" class="headerlink" title="OOP上半部分"></a>OOP上半部分</h1><h1 id="1-1-1-问题产生和引导"><a href="#1-1-1-问题产生和引导" class="headerlink" title="1-1-1 问题产生和引导"></a>1-1-1 问题产生和引导</h1><p>假设有一个养狗系统</p><table><thead><tr><th>面向过程</th><th>面向对象</th></tr></thead><tbody><tr><td>流水线</td><td>模块化</td></tr><tr><td>一件事”该怎么做”</td><td>一件事”该让谁来做”</td></tr><tr><td>狗饿了，狗吃了食物</td><td>属性:狗、食物、饿；动作:狗吃食物</td></tr><tr><td>强调的是“吃”，“狗”只是一个参数</td><td>强调的是“狗”，“吃”只是一个动作</td></tr></tbody></table><p>一件事“该让谁来做”，那个“谁”就是对象，他要怎么做是他自己的事，最后一群对象合力能把事做好了</p><h1 id="1-1-2-对象"><a href="#1-1-2-对象" class="headerlink" title="1-1-2 对象"></a>1-1-2 对象</h1><p><strong>首先我们要明白什么是对象？</strong></p><ul><li>根据词典指行动或思考时作为目标的事物</li><li>简单来说就是你现在所干的事情的目标是为了啥</li></ul><h1 id="1-1-3-变换思维"><a href="#1-1-3-变换思维" class="headerlink" title="1-1-3 变换思维"></a>1-1-3 变换思维</h1><p><strong>思考什么是过程？</strong></p><ul><li>第一步怎么做，第二步怎么做，接着怎么做……最后怎么做(return 0)</li><li>走一步看一步，目标不明确，我们不可能把所有过程写一遍，不适用于大众</li></ul><p><strong>面向过程编程：（POP：Procedure Oriented Programming）</strong></p><ul><li>分析解决问题所需要的步骤，然后用函数把这些一步步实现，使用的时候按顺序依次调用</li><li>代码线性，严格按着顺序，侧重解决步骤，着眼局部或者具体</li></ul><p><strong>面向对象编程：（OOP：Object Oriented Programming）</strong></p><ul><li>该程序，要大众化</li><li>明确目标吗，对象就是目标，目标就是对象</li><li>不强调过程</li></ul><h1 id="1-1-4-规划明确目标站在更高层次思考问题"><a href="#1-1-4-规划明确目标站在更高层次思考问题" class="headerlink" title="1-1-4 规划明确目标站在更高层次思考问题"></a>1-1-4 规划明确目标站在更高层次思考问题</h1><p><strong>明确目标</strong></p><ul><li>计划、规划 设计它</li><li>当你执行完计划时候，达到目标</li><li>OOP:站在更高的层次看待事物</li></ul><h1 id="1-1-5-上代码，设计体验面向对象编程，实例和对象"><a href="#1-1-5-上代码，设计体验面向对象编程，实例和对象" class="headerlink" title="1-1-5 上代码，设计体验面向对象编程，实例和对象"></a>1-1-5 上代码，设计体验面向对象编程，实例和对象</h1><p><strong>首先我们要明白什么是对象(实例)？</strong></p><ul><li>根据词典指行动或思考时作为目标的事物，简单来说就是你现在所干的事情的目标</li><li>显示生活的一个东西，对抽象的东西进行表示出来的产物，是一个活生生存在的事物，它是唯一的</li></ul><p>现在要制作一个What‘s Animal 的软件，那这里面所有的对象就是大家会养的宠物，比如猫猫狗狗等</p><p>这个时候就比如设置一个狗<code>Dogs</code>的类(class)，这个class就是一个狗的基础模型</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dogs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String variety;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String food;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;eat food&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">sleep</span><span class="params">()</span>&#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;狗睡觉&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>myDog</code> 就是一个对象(实例)了，当我们看到 <code>myDog</code> 的时候只会觉得这是一只狗，但是我们不能知道它具体的样子，我们就要继续对这个狗进行描述操作，然后它就会浮现出一个具体的样子，然后在另外一个<code>main()</code>方法里面<code>new</code>一个<code>Dogs</code>对象(实例)</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dogs</span> <span class="variable">myDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dogs</span>();</span><br><span class="line">        myDog.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        myDog.age = <span class="number">2</span>;</span><br><span class="line">        myDog.variety = <span class="string">&quot;哈士奇&quot;</span>;</span><br><span class="line">        myDog.sleep();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../Java-Base/DOG.png" alt="DOG"></p><h1 id="1-1-6-成员变量行为类和this"><a href="#1-1-6-成员变量行为类和this" class="headerlink" title="1-1-6 成员变量行为类和this"></a>1-1-6 成员变量行为类和this</h1><p><strong>在了解什么是属性的时候，我们先思考什么是类(class)？</strong></p><ul><li>我比较倾向把它理解成<strong>分类</strong>的类，回到What‘s Animal 这个软件当中</li><li>软件中有很多的宠物，很多类型的宠物，有猫、狗、猪等等，那我们最好的分类方式就是对不同的动物分类</li></ul><p>这样我们就去创建一个<code>Dogs</code>类</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dogs</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>什么是属性(共性、特性)？</strong></p><ul><li>属性是事物的性质与事物之间关系的统称。</li><li>事物的性质——事物的形状、颜色、气味、善恶、优劣、用途等</li><li>事物的关系——大于、小于、压迫、反抗、朋友、热爱、同盟、矛盾等</li><li>任何属性都是属于某种对象的</li></ul><p>类当中的变量和方法都称为属性(共性、特性)或者成员变量，它们组成和构成了类，所以我们这么命令，它们是类的重要组成部分</p><p>例如同一类动物的特征有身高、体重、毛皮颜色等，会作出吃饭、睡觉等行为，这些特征和行为就是属性</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dogs</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> String name;</span><br><span class="line">    <span class="keyword">public</span> String variety;</span><br><span class="line">    <span class="keyword">public</span> <span class="type">int</span> age;</span><br><span class="line">    <span class="keyword">public</span> String food;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>这些方法(函数)在类中叫行为</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;eat food&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><strong>this 是啥？</strong></p><ul><li>当我们在做英语阅读理解的时候，会看到一种题目叫做文中的xx段xx行的this代表指代的是前文的啥？</li><li>那这个问题就和这个阅读理解一样，计算机在做英语的阅读理解啦，计算机一般比我们聪明些总是能正确的回答</li><li>this的中文意思是“这个”，当我创建好一个对象，并且将它实例化以后，我使用这个对象进行一个操作<code>myDog.sleep()</code>：</li></ul><p><img src="../Java-Base/myDog.sleep%EF%BC%88%EF%BC%89.png" alt="myDog.sleep（）"><br>这个时候回到类里 <code>sleep()</code> 这个方法里，里面有一个<code>this</code>，那很显然这个 <code>this</code> 调用的就是 <code>myDog</code> ，那 <code>myDog.name</code> 不就是Tom嘛</p><p>要是我的英语阅读理解题有这么简单就好了</p><h1 id="1-1-7-注销账户和null空指针异常"><a href="#1-1-7-注销账户和null空指针异常" class="headerlink" title="1-1-7 注销账户和null空指针异常"></a>1-1-7 注销账户和null空指针异常</h1><p>使用软件要进行账户的注册，我们姑且把账户注册等同于制造一个新的对象</p><p>填写完注册信息之后，我们就变成了一个实例，假如我们想注销，这个过程就会把我们的信息从软件上抹去</p><p>这个时候我们对代码进行这样的操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dogs</span> <span class="variable">zhangDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dogs</span>();</span><br><span class="line">        zhangDog.name = <span class="string">&quot;Tom&quot;</span>;</span><br><span class="line">        zhangDog.age = <span class="number">2</span>;</span><br><span class="line">        zhangDog.variety = <span class="string">&quot;哈士奇&quot;</span>;</span><br><span class="line">        <span class="comment">//张大爷想注销账户</span></span><br><span class="line">        zhangDog = <span class="literal">null</span>;</span><br><span class="line">        System.out.println(<span class="string">&quot;zhangDog.name = &quot;</span> + zhangDog.name);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>注销之后如果你就找不到张大爷了！空指针异常啦<br><img src="../Java-Base/%E7%A9%BA%E6%8C%87%E9%92%88%E5%BC%82%E5%B8%B8.png" alt="空指针异常"><br><code>zhangDog</code>相当于一个指针，在内存里指向对象，注销后，指针就指向了一块空的区域，接下来讲说明如果解决这个问题</p><h1 id="1-2-1-OOP封装"><a href="#1-2-1-OOP封装" class="headerlink" title="1-2-1 OOP封装"></a>1-2-1 OOP封装</h1><p><strong>为什么要进行封装？</strong></p><ul><li>如果狗的年龄被改成-30怎么办？这不是出错了吗，或者如果没封装起来，我岂不是可以修改支付宝余额为9999999</li><li>OOP的封装也是如此，我们在一些类里已经写好了很多功能，用户在使用的过程中，不需要理会在类里面写了什么，只要根据自己想实现的功能使用就可以了</li></ul><p><strong>那OOP是如何封装的呢？</strong></p><ul><li>首先我们要明白一个道理就是，数据库的原理对设计它的公司来说是私密的，那我们在封装的过程中也要将变量变成私密的</li></ul><p>但这个时候<code>main()</code>就会出现错误提示<br><img src="../Java-Base/%E5%B0%81%E8%A3%85.png" alt="封装"><br>那我们就无法操作这个类的属性了，这个时候我们就要请上 <code>getter</code> <code>setter</code> 函数了</p><p><img src="../Java-Base/%60getter%60%60setter%60.png" alt="`getter` `setter`"></p><p>把成员变量做的安全，使用<code>private</code>代替<code>public</code>(公共的，用户可以修改此属性)成员变量的特性，另外提供<code>getter and setter</code> ，这种方式叫做oop封装</p><p><code>getter</code> <code>setter</code> 可以看作是一个按钮，这就是封装，而在按钮设置的过程中，你可以对按钮编程，让它符合条件以后才可以被启动</p><h1 id="1-2-2-jar导入和lombok"><a href="#1-2-2-jar导入和lombok" class="headerlink" title="1-2-2 jar导入和lombok"></a>1-2-2 jar导入和lombok</h1><p>下载<code>lombok</code>插件<br><img src="../Java-Base/%E4%B8%8B%E8%BD%BDLombok%E6%8F%92%E4%BB%B6.png" alt="下载Lombok插件"><br><img src="../Java-Base/Lombok.png" alt="Lombok"></p><blockquote><p><strong>lombok的Java包下载详见：<a href="https://mvnrepository.com/artifact/org.projectlombok/lombok/1.18.12">maven repository-Project Lombok</a></strong></p></blockquote><p><img src="../Java-Base/Lombok%E4%BE%9D%E8%B5%96.png" alt="Lombok依赖"><br><img src="../Java-Base/jar%E5%AF%BC%E5%8C%851.png" alt="jar导包1"><br>将下载好的<code>jar</code>文件拖入<code>jar</code>文件夹下<br><img src="../Java-Base/jar%E5%AF%BC%E5%8C%852.png" alt="jar导包2"><br>右击选择<code>Add as Library</code><br><img src="../Java-Base/jar%E5%AF%BC%E5%8C%853.png" alt="jar导包3"><br>选择<code>Projcet Library</code><br><img src="../Java-Base/jar%E5%AF%BC%E5%8C%854.png" alt="jar导包4"><br>此时在类中输入注释，并导入包</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br></pre></td></tr></table></figure><p><img src="../Java-Base/Getter-Setter.png" alt="Getter Setter"></p><p>还需要在设置<code>Annotation Processors</code>中将<code>Enable annotation processing</code>勾选上<br><img src="../Java-Base/%E8%AE%BE%E7%BD%AE.png" alt="设置"><br>重建项目<br><img src="../Java-Base/%E9%87%8D%E5%BB%BA%E9%A1%B9%E7%9B%AE.png" alt="重建项目"><br>完成<br><img src="../Java-Base/%E7%A4%BA%E6%84%8F%E5%9B%BE.png" alt="示意图"><br>这样就不用写<code>getter</code> <code>setter</code>了，但如果有特殊的方法则需要单独写，即方法的重写</p><h1 id="1-2-3-toString"><a href="#1-2-3-toString" class="headerlink" title="1-2-3 toString()"></a>1-2-3 toString()</h1><p><code>toString()</code> 这个方法可以输出相应的对象的函数，<code>alt + insert</code>一键创建<code>getter</code> <code>setter</code>函数<br><img src="../Java-Base/toString1.png" alt="toString1"><br><img src="../Java-Base/toString2.png" alt="toString2"></p><p><img src="../Java-Base/toString3.png" alt="toString3"><br><img src="../Java-Base/toString4.png" alt="toString4"><br>当然也可以利用jar包，在类前加注解</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> lombok.Getter;</span><br><span class="line"><span class="keyword">import</span> lombok.Setter;</span><br><span class="line"><span class="keyword">import</span> lombok.ToString;</span><br><span class="line"></span><br><span class="line"><span class="meta">@Getter</span></span><br><span class="line"><span class="meta">@Setter</span></span><br><span class="line"><span class="meta">@ToString</span></span><br></pre></td></tr></table></figure><p><code>@Date</code>相当于包含以下三种：</p><ul><li><code>toString()</code></li><li><code>Override Methods()</code></li><li><code>Delegate Methods()</code></li></ul><h1 id="1-2-4-构造方法"><a href="#1-2-4-构造方法" class="headerlink" title="1-2-4 构造方法"></a>1-2-4 构造方法</h1><p><strong>回忆一下数组是怎么写的?</strong></p><ul><li>两种不一样的定义和给数组赋值的方式，创建对象的方式和第二种先定义再赋值的方式是一样的</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"> <span class="comment">//1.初始化 定义+赋值</span></span><br><span class="line"><span class="type">int</span>[] arrDogs = &#123;<span class="number">1</span>, <span class="number">2</span>, <span class="number">3</span>, <span class="number">4</span>&#125;;</span><br><span class="line"> </span><br><span class="line"><span class="comment">//2.先定义 后赋值</span></span><br><span class="line"><span class="type">int</span> [] arr = <span class="keyword">new</span> <span class="title class_">int</span>[<span class="number">4</span>];</span><br><span class="line">arr[<span class="number">0</span>] = <span class="number">1</span>;</span><br></pre></td></tr></table></figure><p><strong>我们如何让对象也可以初始化呢？</strong></p><p>这就需要构造方法 <code>alt+insert</code></p><ul><li>构造方法不要有类型，方法名和类名一样</li><li>在一般情况下要加一个空参构造方法</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="title function_">Dogs</span><span class="params">(String name, String variety, <span class="type">int</span> age, String food)</span> &#123;</span><br><span class="line">    <span class="built_in">this</span>.name = name;</span><br><span class="line">    <span class="built_in">this</span>.variety = variety;</span><br><span class="line">    <span class="built_in">this</span>.age = age;</span><br><span class="line">    <span class="built_in">this</span>.food = food;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="title function_">Dogs</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>然后就可以实现对象的初始化</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Dogs</span> <span class="variable">zhangDog</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Dogs</span>(<span class="string">&quot;Tom&quot;</span>, <span class="string">&quot;哈士奇&quot;</span>, <span class="number">2</span>,<span class="literal">null</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><h1 id="1-2-5-构造方法的重载与再探this"><a href="#1-2-5-构造方法的重载与再探this" class="headerlink" title="1-2-5 构造方法的重载与再探this"></a>1-2-5 构造方法的重载与再探this</h1><p>构造方法也是可以重载的<br><img src="../Java-Base/%E9%87%8D%E8%BD%BD.png" alt="重载"></p><h1 id="1-2-6-垃圾回收"><a href="#1-2-6-垃圾回收" class="headerlink" title="1-2-6 垃圾回收"></a>1-2-6 垃圾回收</h1><p><strong>回到1-1-7，找不到张大爷了，空指针异常怎么办？</strong></p><ul><li>java一般是不需要你手动回收的，如果一定要自己手动来垃圾回收，可以使用<code>System.gc()</code> 这个方法</li></ul><p><img src="../Java-Base/%E5%9E%83%E5%9C%BE%E5%9B%9E%E6%94%B6.png" alt="垃圾回收"><br>这样就不会出现空指针异常了</p><h1 id="1-2-7-静态变量和静态方法"><a href="#1-2-7-静态变量和静态方法" class="headerlink" title="1-2-7 静态变量和静态方法"></a>1-2-7 静态变量和静态方法</h1><p>静态变量</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">plot</span> <span class="operator">=</span><span class="string">&quot;NanG&quot;</span>;</span><br></pre></td></tr></table></figure><p>静态方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">goplot</span><span class="params">()</span>&#123;</span><br><span class="line">    System.out.println(<span class="string">&quot;所有狗都进了小区&quot;</span>);</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../Java-Base/%E9%9D%99%E6%80%81%E5%8F%98%E9%87%8F%E4%B8%8E%E9%9D%99%E6%80%81%E6%96%B9%E6%B3%95.png" alt="静态变量与静态方法"></p><h1 id="1-2-8-private-static"><a href="#1-2-8-private-static" class="headerlink" title="1-2-8 private static"></a>1-2-8 private static</h1><p><strong>万一静态变量被改了怎么办？</strong></p><p>咱们小区名被黑了<br><img src="../Java-Base/%E5%85%AC%E5%85%B1%E5%8F%98%E9%87%8F.png" alt="公共变量"><br>这就需要用到<code>private static</code></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="type">String</span> <span class="variable">plot</span> <span class="operator">=</span><span class="string">&quot;NanG&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getPlotInstance</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> plot;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    System.out.println(<span class="string">&quot;Dogs.getPlotInstance() = &quot;</span> + Dogs.getPlotInstance());</span><br></pre></td></tr></table></figure><p>这样定义变量和方法只能在有类名来使用，可以看作是所有类都必须做的事情，而对象无法使用，对象无权选择或者不选择。</p><h1 id="1-2-9-static单例模式"><a href="#1-2-9-static单例模式" class="headerlink" title="1-2-9 static单例模式"></a>1-2-9 static单例模式</h1><p><strong>单例模式怎么来的？</strong></p><ul><li><code>private static</code>定义变量和方法只能在有类名来使用，可以看作是所有类都必须做的事情，而对象无法使用，对象无权选择或者不选择，这里就衍生出了一种设计模式：单例模式</li></ul><p><strong>单例模式怎么用？</strong></p><ul><li>单例模式的存在是为了保证一个类仅有一个实例，无法克隆，并提供一个访问它的全局访问点</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Earth</span> &#123;</span><br><span class="line">    <span class="comment">//new 一个新的地球，只有Earth类内可以调用</span></span><br><span class="line">    <span class="keyword">private</span> <span class="keyword">static</span> <span class="type">Earth</span> <span class="variable">earthInstance</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Earth</span>();</span><br><span class="line"></span><br><span class="line">    <span class="comment">//外部无法new新的Earth</span></span><br><span class="line">    <span class="keyword">private</span> <span class="title function_">Earth</span><span class="params">()</span>&#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="comment">//Earth在外部得到Earth</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> Earth <span class="title function_">getEarthInstance</span><span class="params">()</span>&#123;</span><br><span class="line">        <span class="keyword">return</span> earthInstance;</span><br><span class="line">    &#125;</span><br><span class="line">    </span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">showMessage</span><span class="params">()</span>&#123;</span><br><span class="line">      System.out.println(<span class="string">&quot;Hello Earth!&quot;</span>);</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">main</span> &#123;</span><br><span class="line">   <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//不合法的构造函数</span></span><br><span class="line">      <span class="comment">//编译时错误：构造函数 Earth() 是不可见的</span></span><br><span class="line">      <span class="comment">//Earth object = new Earth();</span></span><br><span class="line"> </span><br><span class="line">      <span class="comment">//获取唯一可用的对象</span></span><br><span class="line">      <span class="type">Earth</span> <span class="variable">object</span> <span class="operator">=</span> Earth.getEarthInstance();</span><br><span class="line"> </span><br><span class="line">      <span class="comment">//显示消息</span></span><br><span class="line">      object.showMessage();</span><br><span class="line">   &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="string">&quot;Hello Earth!&quot;</span></span><br></pre></td></tr></table></figure><blockquote><p><strong>参考：</strong></p><ul><li><strong><a href="https://www.runoob.com/design-pattern/singleton-pattern.html">单例模式-菜鸟教程</a></strong></li></ul></blockquote><h1 id="1-2-10-内部类"><a href="#1-2-10-内部类" class="headerlink" title="1-2-10 内部类"></a>1-2-10 内部类</h1><p><strong>内部类是啥？</strong></p><ul><li>类里面再来一个类</li><li>静态内部类只能用静态变量</li><li>方法内部类，只能在方法里面用</li><li>用的比较少，十分难维护，可以自己去了解</li></ul><h1 id="OOP下半部分"><a href="#OOP下半部分" class="headerlink" title="OOP下半部分"></a>OOP下半部分</h1><h1 id="面向对象三大特性：封装-继承-多态"><a href="#面向对象三大特性：封装-继承-多态" class="headerlink" title="面向对象三大特性：封装 继承 多态"></a>面向对象三大特性：封装 继承 多态</h1><h1 id="2-1-1-需求重定义"><a href="#2-1-1-需求重定义" class="headerlink" title="2-1-1 需求重定义"></a>2-1-1 需求重定义</h1><p><strong>我们的宠物系统要如何维护呢？</strong></p><p>人们养宠物会有很多的选择，除开狗以外还会有猫、老鼠、熊、猪等等等</p><h1 id="2-1-2-继承"><a href="#2-1-2-继承" class="headerlink" title="2-1-2 继承"></a>2-1-2 继承</h1><p><strong>如何将这些重复的代码进行一个归类和总结呢？</strong></p><ul><li>我们会有许多方法去维护这个软件，如果要把所有动物的类都写上去，你会发现写上的都是重复的代码，我们需要将重复代码进行总结，由此提出概念：继承</li></ul><p><strong>什么是继承？</strong></p><ul><li>泛指把前人的作风、文化、知识等接受过来</li><li>把重复的代码放在一块，让其他的动物接受过来，这也是一种继承</li></ul><p>我可以创造一个类叫”动物”，这样其他的动物都可以在”动物”类中继承相同的地方，继承的关键词是 <code>extends</code><br><img src="../Java-Base/%E7%BB%A7%E6%89%BF.png" alt="继承"><br>我们把原来属于Dogs的内容转移到了<code>Animal</code>中，使用 <code>extends</code> ，最后在主函数中像之前一样<code>Dogs</code>类</p><p>并且 <code>Cat</code>在继承<code>Pet</code>以后也可以像狗一样实践，这样就使得我们的代码的复用性很强，也符合了大众化</p><h1 id="2-2-2-多层继承"><a href="#2-2-2-多层继承" class="headerlink" title="2-2-2 多层继承"></a>2-2-2 多层继承</h1><p><strong>什么是多层继承 ？</strong></p><ul><li>像灰太狼家族，一层一层的继承，爷爷传承到爸爸、爸爸传承到孙子</li><li>一个类不能直接继承多个类，java是单继承语言，不支持多继承</li><li>不能写成 <code>class A extends B,C</code></li><li>但可以实现继承多个类 <code>class A extends B，class C extends A</code> 这样C就同时继承了B和A两个类了</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Dogs</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Labrador</span> <span class="keyword">extends</span> <span class="title class_">Dogs</span> &#123;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><img src="../Java-Base/%E5%A4%9A%E5%B1%82%E7%BB%A7%E6%89%BF.png" alt="多层继承"></p><h1 id="2-2-3-方法的重写"><a href="#2-2-3-方法的重写" class="headerlink" title="2-2-3 方法的重写"></a>2-2-3 方法的重写</h1><p><strong>如果要对继承中某个方法进行修改怎么办？</strong></p><ul><li>在类继承了另外一类，但是对一些方法需要进行修改的时候就需要用到方法的重写，比如动物的叫声不同</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br></pre></td><td class="code"><pre><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breaking</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        super.breaking();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;喵喵&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breaking</span><span class="params">()</span> &#123;</span><br><span class="line"><span class="comment">//        super.breaking();</span></span><br><span class="line">        System.out.println(<span class="string">&quot;汪汪&quot;</span>);</span><br><span class="line">    &#125;</span><br></pre></td></tr></table></figure><p>动物叫，这是它自己拥有的特性，是他自己写的，不是来自他爸的，他从爸爸那革新了</p><p>子类自己认为，应该打破它父亲的传统，进行革新，革新的内容就是方法体</p><p><code>super</code> 这个函数是继承父类的所有方法，如果要改写就需要将这个注释掉<br><img src="../Java-Base/%E6%96%B9%E6%B3%95%E7%9A%84%E9%87%8D%E5%86%99.png" alt="方法的重写"><br><strong>重写(Override)与重载(Overload)的区别是啥？</strong></p><ul><li>重写(Override)是子类对父类的允许访问的方法的实现过程进行重新编写, 返回值和形参都不能改变</li><li>重载(Overload)是在一个类里面，方法名字相同，而参数不同。返回类型可以相同也可以不同</li></ul><blockquote><p><strong>参考：</strong></p><ul><li><strong><a href="https://www.runoob.com/java/java-override-overload.html">Java 重写(Override)与重载(Overload)-菜鸟教程</a></strong></li></ul></blockquote><h1 id="2-2-4-super啃老"><a href="#2-2-4-super啃老" class="headerlink" title="2-2-4 super啃老"></a>2-2-4 super啃老</h1><p>super啃老就是引用父类的方法，如图所示。<br><img src="../Java-Base/%E5%95%83%E8%80%81.png" alt="啃老"></p><h1 id="2-2-5-啃老啃到彻底"><a href="#2-2-5-啃老啃到彻底" class="headerlink" title="2-2-5 啃老啃到彻底"></a>2-2-5 啃老啃到彻底</h1><p><strong>构造方法的重写</strong></p><p>继承无法继承父类的构造函数，所以还需要重写构造方法，这样才可以进行对象的初始化</p><p><img src="../Java-Base/%E9%87%8D%E5%86%991.png" alt="重写1"><br><img src="../Java-Base/%E9%87%8D%E5%86%992.png" alt="重写2"></p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br></pre></td><td class="code"><pre><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">(String name, String variety, <span class="type">int</span> age, String food)</span> &#123;</span><br><span class="line">        <span class="built_in">this</span>.name = name;</span><br><span class="line">        <span class="built_in">this</span>.variety = variety;</span><br><span class="line">        <span class="built_in">this</span>.age = age;</span><br><span class="line">        <span class="built_in">this</span>.food = food;</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Animal</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">(String name, String variety, <span class="type">int</span> age, String food)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, variety, age, food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Cat</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dogs</span><span class="params">(String name, String variety, <span class="type">int</span> age, String food)</span> &#123;</span><br><span class="line">        <span class="built_in">super</span>(name, variety, age, food);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="title function_">Dogs</span><span class="params">()</span> &#123;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-2-6-final"><a href="#2-2-6-final" class="headerlink" title="2-2-6 final"></a>2-2-6 final</h1><p><strong>遗产没人继承了，也不可能继承–final</strong></p><p>例如我们创建一个拉布拉多类继承<code>Dogs</code>类，并用<code>final</code>定义</p><ul><li>用<code>final</code>定义的类不能再被继承</li><li>用<code>fianl</code>定义的方法不能再被重写</li><li>用<code>final</code>定义的变量是常量且不能再被修改</li></ul><p>方法也有重写，拿狗是否能导航来举例，<code>Dogs</code>类不加<code>final</code>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="type">boolean</span> <span class="title function_">isGudieBlindness</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Dogs</code>类加<code>final</code>结果：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">final</span> <span class="type">boolean</span> <span class="title function_">isGudieBlindness</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> <span class="literal">false</span>;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p><code>Labrador</code>类不能重写<code>fianl</code>的方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="string">&#x27;isGudieBlindness()&#x27;</span> cannot override <span class="string">&#x27;isGudieBlindness()&#x27;</span> in <span class="string">&#x27;com.microsoft.demo.Dogs&#x27;</span>; overridden method is <span class="keyword">final</span></span><br></pre></td></tr></table></figure><p>再例如，用<code>final</code>定义的变量是常理，而在命令规范中，常理必须大写，单词用下划线隔开</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> <span class="keyword">final</span> <span class="type">String</span> <span class="variable">COMMUNITY_NAME</span> <span class="operator">=</span><span class="string">&quot;NanG&quot;</span>;</span><br><span class="line"><span class="keyword">public</span> <span class="keyword">static</span> String <span class="title function_">getCommunityName</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="keyword">return</span> COMMUNITY_NAME;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>快捷键：<br><code>ctrl +shift+u</code>一键大写<br><code>shift+f6</code>一键更改变量</p><h1 id="2-2-7-提出新的问题"><a href="#2-2-7-提出新的问题" class="headerlink" title="2-2-7 提出新的问题"></a>2-2-7 提出新的问题</h1><p><strong>那new Animal()是不是没用了？——抽象概念的引出</strong></p><ul><li>在这个系统中<code>Animal</code>类是一个没有抽象的类，就像你养一只动物肯定是具体猫或狗等，因此，<code>Animal</code>这个类是不会能被 <code>new</code>的，这样就涉及了抽象类的概念</li><li><code>Animal</code>类是用来继承的，没人会用<code>Animal</code>，我们创建对象的时候只会用到猫猫狗狗类</li><li>如果子类继承了父类，但是并未给子类写行为的具体内容，这样子类调用行为的时候出现的是父亲的行为，也就是说，如果我们定义仓鼠叫，输出的是”动物叫”，而不是仓鼠的具体叫声</li></ul><p>万一我们创建的仓鼠类，没有定义叫声怎么办？抽象类来解决这个问题</p><h1 id="2-3-1-抽象与具体——抽象类的衍生"><a href="#2-3-1-抽象与具体——抽象类的衍生" class="headerlink" title="2-3-1 抽象与具体——抽象类的衍生"></a>2-3-1 抽象与具体——抽象类的衍生</h1><p><strong>你不能养一个抽象”动物”，而是具体养了”什么”</strong></p><ul><li><code>Animal</code>本质来说是没有人用的，它是一个抽象的，它抽取了这些猫狗的共性，作为使用</li><li>抽象的反义词是具体，抽象的目的是为了概括(解释)这些具体事物</li><li>加入抽象类的关键词是 <code>abstract</code> ，抽象类是不能再被 <code>new</code> 的类，但是它可以被其他的类继承</li></ul><h1 id="2-3-2-抽象方法和抽象类的使用"><a href="#2-3-2-抽象方法和抽象类的使用" class="headerlink" title="2-3-2 抽象方法和抽象类的使用"></a>2-3-2 抽象方法和抽象类的使用</h1><p><strong>如何理解抽象方法的作用呢？</strong></p><ul><li>你会发现，想像一下，动物的叫声太多了，我们可以统一叫这个行为，但是我们不能统一他们的叫的方式一样（叫声一样），所以我们要在具体类中具体他们的叫声</li><li>同时使用抽象方法可以起到提示作用，因为抽象方法必须重写，如果忘记重写就会有报错</li><li><code>Animal</code>类中抽象方法是不能有实际意义的</li></ul><p>应该这么写（举例）</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">abstract</span> <span class="keyword">void</span> <span class="title function_">breaking</span><span class="params">()</span>;</span><br></pre></td></tr></table></figure><p>继承抽象类(<code>Animal</code>类)的子类(<code>Cat</code>类)必须重写父类的抽象方法，且抽象方法必须在抽象类中</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">pubilc <span class="keyword">class</span> <span class="title class_">Cat</span> <span class="keyword">extends</span> <span class="title class_">Animal</span>&#123;</span><br><span class="line"></span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>同时子类也无法<code>super</code>父类了，因为父类没有这个方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">breaking</span><span class="params">()</span>&#123;</span><br><span class="line">    <span class="built_in">super</span>.breaking();</span><br><span class="line">    System.out.printf(<span class="string">&quot;www&quot;</span>)</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-3-3-接口"><a href="#2-3-3-接口" class="headerlink" title="2-3-3 接口"></a>2-3-3 接口</h1><p><strong>如果方法全是抽象的怎么办？</strong></p><ul><li>在抽象类中有抽象方法，如果把抽象类里的方法全部变成抽象方法，可以用接口来替代这个抽象类</li></ul><p><code>New Java Class</code> 选择<code>Interface</code><br><img src="../Java-Base/interface.png" alt="interface"><br>接口里面所有方法都是抽象的，实现接口的类，会把接口中定义的方法全部重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">interface</span> <span class="title class_">Human</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span>;</span><br><span class="line"></span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Chinese</span> <span class="keyword">implements</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃中餐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;小跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Westerner</span> <span class="keyword">implements</span> <span class="title class_">Human</span>&#123;</span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;吃西餐&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line">        System.out.println(<span class="string">&quot;大步跑&quot;</span>);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br><span class="line"></span><br><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">        <span class="type">Chinese</span> <span class="variable">chinese</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Chinese</span>();</span><br><span class="line">        chinese.eat();</span><br><span class="line">        chinese.run();</span><br><span class="line"></span><br><span class="line">        <span class="type">Westerner</span> <span class="variable">westerner</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Westerner</span>();</span><br><span class="line">        westerner.eat();</span><br><span class="line">        westerner.run();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="2-3-4-class和interface的区别"><a href="#2-3-4-class和interface的区别" class="headerlink" title="2-3-4 class和interface的区别"></a>2-3-4 class和interface的区别</h1><p><strong>接口和抽象类本质上有什么区别？</strong></p><ul><li>抽象类是针对具体的事物进行抽象</li><li>接口是针对动作、行为进行抽象，且接口中避免出现名词</li></ul><h1 id="2-4-1-多态"><a href="#2-4-1-多态" class="headerlink" title="2-4.1 多态"></a>2-4.1 多态</h1><p><strong>多态是什么？</strong></p><ul><li>多态是同一个行为具有多个不同表现形式或形态的能力</li><li>多态就是同一个接口，使用不同的实例而执行不同操作</li></ul><p><strong>多态存在的三个必要条件</strong></p><ul><li>继承</li><li>重写</li><li>父类引用指向子类对象：<code>Parent p = new Child();</code></li></ul><p><strong>向上转型</strong></p><ul><li>子类引用的对象转换为父类</li><li>此处父类对象可以是接口</li><li>花木兰替父从军就是向上转型，隐藏子类</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Animal</span> <span class="variable">a</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Cat</span>();</span><br></pre></td></tr></table></figure><p><strong>向下转型</strong></p><ul><li>把父类对象转为子类对象</li><li>前提是父类对象指向的是子类对象，即在向下转型之前，它得先向上转型</li><li>向下转型只能转型为本类对象（猫是不能变成狗的）</li><li>做回自己就是向下转型，开始变换</li></ul><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="type">Cat</span> <span class="variable">c</span> <span class="operator">=</span> ((Cat) a);</span><br></pre></td></tr></table></figure><blockquote><p><strong>参考：</strong></p><ul><li><strong><a href="https://www.runoob.com/w3cnote/java-polymorphism.html">Java 中的多态-菜鸟教程</a></strong></li></ul></blockquote><h1 id="2-4-2-匿名内部类"><a href="#2-4-2-匿名内部类" class="headerlink" title="2-4-2 匿名内部类"></a>2-4-2 匿名内部类</h1><p><strong>为什么叫匿名内部类？</strong></p><p><img src="../Java-Base/%E5%8C%BF%E5%90%8D%E5%86%85%E9%83%A8%E7%B1%BB.png" alt="匿名内部类"></p><ul><li>匿名内部类也就是没有名字的内部类</li><li>如果某个局部类你只需要用一次，那么你就可以使用匿名内部类</li><li>使用匿名内部类必须继承一个父类或实现一个接口</li></ul><p>抽象类是不能被<code>new</code>的，但是接口可以，<code>new</code>接口时会自动创建重写</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="keyword">class</span> <span class="title class_">Application</span> &#123;</span><br><span class="line">    <span class="keyword">public</span> <span class="keyword">static</span> <span class="keyword">void</span> <span class="title function_">main</span><span class="params">(String[] args)</span> &#123;</span><br><span class="line">     <span class="type">Human</span> <span class="variable">xiaoming</span> <span class="operator">=</span> <span class="keyword">new</span> <span class="title class_">Human</span>() &#123;</span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">eat</span><span class="params">()</span> &#123;</span><br><span class="line">             System.out.println(<span class="string">&quot;吃中国菜&quot;</span>);</span><br><span class="line">         &#125;</span><br><span class="line"></span><br><span class="line">         <span class="meta">@Override</span></span><br><span class="line">         <span class="keyword">public</span> <span class="keyword">void</span> <span class="title function_">run</span><span class="params">()</span> &#123;</span><br><span class="line"></span><br><span class="line">         &#125;</span><br><span class="line">     &#125;;</span><br><span class="line">     xiaoming.eat();</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h1 id="3-1-1-权限修饰符"><a href="#3-1-1-权限修饰符" class="headerlink" title="3-1-1 权限修饰符"></a>3-1-1 权限修饰符</h1><p>话不多说，直接上教程，都是概念性的东西。</p><blockquote><p><strong>参考：</strong></p><ul><li><strong><a href="https://www.runoob.com/java/java-modifier-types.html">Java 修饰符-菜鸟教程</a></strong></li></ul></blockquote><h1 id="3-1-2-Object"><a href="#3-1-2-Object" class="headerlink" title="3-1-2 Object"></a>3-1-2 Object</h1><p><code>Java Object</code> 类是所有类的父类， Java 的所有类都继承了 <code>Object</code>，子类可以使用 <code>Object</code> 的所有方法</p><p>我们创建一个类时，如果没有明确继承一个父类，那么它就会自动继承 <code>Object</code>，成为 <code>Object</code> 的子类</p><blockquote><p><strong>参考：</strong></p><ul><li><strong><a href="https://www.runoob.com/java/java-object-class.html">Java Object 类-菜鸟教程</a></strong></li></ul></blockquote>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> program </tag>
            
            <tag> java </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Data Structure and algorithm</title>
      <link href="/blog/2023/09/04/Data-Structure-and-algorithm/"/>
      <url>/blog/2023/09/04/Data-Structure-and-algorithm/</url>
      
        <content type="html"><![CDATA[<h3 id="0-0-剖析数据结构的含义，数据结构的用途，区分数据结构与算法"><a href="#0-0-剖析数据结构的含义，数据结构的用途，区分数据结构与算法" class="headerlink" title="0-0.剖析数据结构的含义，数据结构的用途，区分数据结构与算法"></a>0-0.剖析数据结构的含义，数据结构的用途，区分数据结构与算法</h3><blockquote><ol><li>什么是数据结构？</li></ol></blockquote><p>数据结构（英语：data structure）是计算机中存储，组织数据的方式。</p><p>总的来说就是（1）数据的（2）存储与（3）组织。</p><blockquote><ol><li>分别解释其含义？</li></ol></blockquote><p>1）数据：比如我们的QQ号，微信ID，支付密码了；这些都叫数据；</p><p>2）存储：以何种方式存放数据，链表，数组，树，图。。。</p><p>3）组织：CRUD增删改查；</p><p>线性表就是数组，国际上没有线性表这个词，是我们直译过来的；线性表直接用Array数组表达就好。</p><blockquote><ol><li>数据结构与算法的关系？</li></ol></blockquote><p>他们是独立的关系，不是学数据结构我就要一定会算法，这是我国的教育方式罢了；算法只是研究组织数据结构最优的CRUD解。它是更好的，更有效地对数据存储。</p><h3 id="1-0-内存，内存是如何保存不同数据类型的"><a href="#1-0-内存，内存是如何保存不同数据类型的" class="headerlink" title="1-0.内存，内存是如何保存不同数据类型的"></a>1-0.内存，内存是如何保存不同数据类型的</h3><blockquote><p>1)数据在内存中存储应该是什么样的？</p></blockquote><p>内存条中像图中的每一个单元格都是有自己的地址，一个格子可以是一个字节，那么如果要存取一个大型数据(比如一个4字节的数据)，就必须存储在连续的单元格。</p><p><img src="../Data-Structure-and-algorithm/%E5%8D%95%E5%85%83%E6%A0%BC.png" alt="单元格"></p><blockquote><p>拿int（占用4个字节）举例，有数组 int arr[1,2];</p></blockquote><p>假如1号单元格已被占用，那么，如果我们存储数组中的1，就必须重新分配一个连续的空间，比如2，3，4，5；</p><blockquote><p>生活中的例子：</p></blockquote><p>住院部，几个病人要求住在连续序号的房间中；</p><h3 id="1-1-int类型的范围是如何计算的？为什么会占用四个字节？四个字节为什么可以表示该范围？内存中是怎样的"><a href="#1-1-int类型的范围是如何计算的？为什么会占用四个字节？四个字节为什么可以表示该范围？内存中是怎样的" class="headerlink" title="1-1.int类型的范围是如何计算的？为什么会占用四个字节？四个字节为什么可以表示该范围？内存中是怎样的"></a>1-1.int类型的范围是如何计算的？为什么会占用四个字节？四个字节为什么可以表示该范围？内存中是怎样的</h3><p>语言不重要。</p><blockquote><p>1)在c&#x2F;c++中：</p></blockquote><p>不同的编程语言中取值范围是不同的。在c&#x2F;c++语言中int范围取决于字长。 字长是计算机处理的最大位数，与cpu有关。所以了，在32位机器上，字长就是32位，此时表示范围：2^32。<br>考虑正负号(有符号位):表示范围为-(231)<del>(231)-1<br>不考虑正负号( 无符号位):表示范围为 0</del>(2^32)-1</p><blockquote><p>2）python：</p></blockquote><p>python中int范围表示是无限的。</p><h3 id="2-0-Computational-Analysis-of-algorithms计算机算法复杂度分析的基本含义"><a href="#2-0-Computational-Analysis-of-algorithms计算机算法复杂度分析的基本含义" class="headerlink" title="2-0.Computational Analysis of algorithms计算机算法复杂度分析的基本含义"></a>2-0.Computational Analysis of algorithms计算机算法复杂度分析的基本含义</h3><blockquote><p>引出时间复杂度与空间复杂度。</p></blockquote><p>以从不同的目的地去往市中心为例子,如下图：</p><p><img src="../Data-Structure-and-algorithm/go-downtown.png" alt="go-downtown"></p><p>去往市中心（downtown）有三个地点（a,b,c），从图中看出三地路程不尽相同。</p><p>而去往downtown的快慢取决于路的远近和所使用的交通工具。现在呢，从a,b,c地都有人出发去往市中心，a地乘客使用飞机，b地乘客使用拖拉机，c地乘客使用汽车。最终，a先到达，b最后到达。从这个例子中我们发现，不是路程近就能先到达，它与两个因素都有关。计算机同理。<br>在计算机中我们可以把路程比作空间复杂度，所使用的交通工具比作时间复杂度。我们通常所说的时间复杂度是使用相同计算能力的机器，考虑如何在更短的时间能够完成任务。</p><blockquote><p>在计算机中，空间复杂度难以度量。</p></blockquote><h3 id="3-0-Big-O-notation复杂度标记符以及举例"><a href="#3-0-Big-O-notation复杂度标记符以及举例" class="headerlink" title="3-0.Big O notation复杂度标记符以及举例"></a>3-0.Big O notation复杂度标记符以及举例</h3><p>1）该如何理解这些复杂度的数值？</p><p>以数组为例</p><p>O(1) 查找某个病房的住的是谁</p><p>O(n)医生早上查病房，每个病人都要去看一遍</p><p>O(n^2)每个对象与所有对象依次配对 ；</p><h3 id="3-1-复杂度对比函数图"><a href="#3-1-复杂度对比函数图" class="headerlink" title="3-1.复杂度对比函数图"></a>3-1.复杂度对比函数图</h3><p><img src="../Data-Structure-and-algorithm/%E5%A4%8D%E6%9D%82%E5%BA%A6%E5%AF%B9%E6%AF%94.png" alt="复杂度对比"></p><h3 id="3-2-最基础的对数复习。"><a href="#3-2-最基础的对数复习。" class="headerlink" title="3-2.最基础的对数复习。"></a>3-2.最基础的对数复习。</h3><blockquote><p>1）什么是对数?</p></blockquote><p>对于指数：2^3&#x3D;8 ,对数就是问 2的几次方&#x3D;8 。答案是3。</p><blockquote><p>2)介绍log2n的含义，为什么它的值越来越平滑？</p></blockquote><p> 从上节图中可以发现问题，为什么logn越的值来越平滑？<br>举个数组扩容例子。</p><blockquote><p>如下数组：<br>int arr[1];<br>int arr[1，2];<br>int arr[1，2，3，4];<br>int arr[1，2，3，4，5，6，7，8];<br>int arr[1，2，3，4，5，6，7，8，9，10，11，12，13，14，15，16];</p></blockquote><p>我们现在需要做的事情是：如果我该数组已经使用完，而我还需要在该数组存放元素，那么我就需要先把该数组扩容为原来的1倍。然后接着在数组中存放元素，如果我又用完了，我就接着扩容。一直如此。<br>对于上述数组：<br>要变做int arr[1，2];则是在int arr[1]基础上扩容一倍；<br>要变做int arr[1，2，3，4];则是在int arr[1，2]基础上扩容一倍；<br>…</p><blockquote><p>上述数组长度变化：1-&gt;2-&gt;4-&gt;8-&gt;16-&gt;32-&gt;64…-&gt;2^N。</p></blockquote><p>长度为1的数组，经过n次不断的扩容，数组会变得会变得非常大。而随后的每次扩容出来的值会更大，你一下子也很难用完，想再去扩容也会变得很慢，所以这个值会很平缓。</p><h3 id="4-0-Array"><a href="#4-0-Array" class="headerlink" title="4-0.Array"></a>4-0.Array</h3><blockquote><p>提及国内翻译错误？</p></blockquote><p>国际上没有线性表( Linear list )这个概念；</p><p>Linear list 就是Array 和Linked list，而不是线性表，直接说成数组和链表</p><blockquote><p>如何理解数组在内存中的<strong>存储</strong>以及如何<strong>找到</strong>想要的<strong>指定元素</strong>位置？</p></blockquote><p><img src="../Data-Structure-and-algorithm/%E5%8D%95%E5%85%83%E6%A0%BC.png" alt="单元格"></p><p>我们要存储数组 int arr[1,2,3,4]；</p><blockquote><p>前提：首先呢 ，在内存中1号位置已经被占用，那么现在我们要存储该数组中的四个元素，需要怎么存储呢。</p></blockquote><p>首先我们每一个格子是一个字节，而数组中的每一个整形数据都为4个字节，那么数组中4个元素 则需要 4*4&#x3D;16个字节，而一号位置已经被占用，则从2号位置开始放 这些元素，存放完这些元素要到17号停止。</p><p>那么我们要访问指定元素（下标为n所在位置的元素值），只需要套用如下公式，首地址+sizeof（数据长度）*n。</p><p>比如3号元素 ： 2+4*3 &#x3D; 14，那么3号位置的元素就是从14号开始的。</p><h3 id="4-1-Static-Array-复杂度分析"><a href="#4-1-Static-Array-复杂度分析" class="headerlink" title="4-1.Static Array 复杂度分析"></a>4-1.Static Array 复杂度分析</h3><p>1）<strong>查早与修改时间复杂度？</strong></p><p>通过四则运算就能够找到对应下标，然后修改对应的值即可。</p><p>时间复杂度：O (1) T</p><p>2）<strong>插入考虑 RAM的随机性？在首中尾位插入？时间复杂度？</strong></p><p> 你想在首部，中部，和尾部直接插入元素有没有考虑到该数组周围已经被占用了。所以你只能重新找一片新的空间，复制原来的元素再加上新元素。copy的复杂度为O(n),而插入新元素时间复杂度为O（1），总的时间复杂度为O(n+1)，化简得O(n);</p><p>为什么1可以忽略掉？ 那假如O(n^2+2n)，2n可以忽略掉吗？</p><p>当数据量特别大得时候，比如100万，它的平方和乘2倍，哪个大？</p><p>相对于n^2而言，2n小的可怜，所以我们可以把它化简掉。就像你都已经欠债100万元，还在乎再欠上100块？</p><p>3）<strong>删除得时间复杂度？在数组首，尾，中 ，删除有区别吗？</strong></p><p>首先先给出结论。删除数组首，中间的元素时间复杂度是O(n)T，删除末尾是O(1)T。</p><p>为什么？</p><p>首地址不能变，且数组的元素必须连续。所以要删除第一个元素，或者中间的某个元素只能把后面的元素在复盖到前一位来。</p><p>在末尾直接删除，首地址没有变，且删除后剩余数组元素是连续的。</p><p>假如要多次删除首元素，时间复杂度有多高？我们使用它是不是有点蠢？</p><p>假如n个元素，要删除n次，第一个元素，则时间复杂度为O(n*n)。</p><p>解决办法：</p><p><strong>面试题</strong>：jvm中的mark and —sweep（标记and清除） 。 就是先把要删除的都先标记，再后统一把后面的往前移。时间复杂度为O(n)</p><h3 id="4-2-Dynamic-Array扩容复杂度分析，剖析高级语言中的ArrayList原理，提及复杂度震荡的情况"><a href="#4-2-Dynamic-Array扩容复杂度分析，剖析高级语言中的ArrayList原理，提及复杂度震荡的情况" class="headerlink" title="4-2.Dynamic Array扩容复杂度分析，剖析高级语言中的ArrayList原理，提及复杂度震荡的情况"></a>4-2.Dynamic Array扩容复杂度分析，剖析高级语言中的ArrayList原理，提及复杂度震荡的情况</h3><blockquote><p>1)动态数组就是抢先分配，提前分配出1倍的空间。</p></blockquote><blockquote><p>2)扩容复杂度为什么是O(n),谈谈高数中的级数收敛？</p></blockquote><p>比如数组int arr[1];</p><p>现在数组要变成 ：</p><p>int arr[1，2];</p><p>int arr[1，2，3，4];</p><p>int arr[1，2，3，4，5，6，7，8];</p><p>int arr[1，2，3，4，5，6，7，8，9，10，11，12，13，14，15，16];</p><p>要变做int arr[1，2];则是在int arr[1]基础上扩容一倍；</p><p>要变做int arr[1，2，3，4];则是在int arr[1，2]基础上扩容一倍；</p><p> 对于元素3，插入1，2元素的时间复杂度都为O(1),而3，是在原来元素基础上扩容出来一倍，然后再插入3这个元素，在这时它的时间复杂度为O(n+1)为O(n),而4这个元素再插入时时间复杂度为O(1)，因为4这个元素的空间已经是扩容出来的。</p><p>所以上述不断地扩容时间复杂度为</p><p>O(1)+O(2)+O(4)+ O(8)+O(16)+O(32)+…+O(n)&#x3D;O(2n)化简为O(n)</p><p>计算用到高数中的级数收敛：N+N&#x2F;2+N&#x2F;4+N&#x2F;8+N&#x2F;16+N&#x2F;32+…1 约等于2N</p><blockquote><p>上述方法有个装逼的词语？</p></blockquote><p>平摊分析。维基百科搜索平摊分析，里面有对数组平摊分析的介绍。<br>缩容分析？</p><h3 id="5-0-Linked-list与Singly-linked-list含义以及复杂度分析举例"><a href="#5-0-Linked-list与Singly-linked-list含义以及复杂度分析举例" class="headerlink" title="5-0.Linked list与Singly linked list含义以及复杂度分析举例"></a>5-0.Linked list与Singly linked list含义以及复杂度分析举例</h3><p>用解密游戏理解单链表。拿到每个地方的道具，同时哪里还存储着下个存储宝藏所在地的信息。</p><blockquote><p>什么是头节点，节点？</p></blockquote><p>单链表的时间复杂度</p><p>查：从第一个开始遍历，直到找到你要的值O(n)</p><p>插入：从头开始遍历，找到要插入的元素位置；</p><p>先查找，再插入 O(n)+O(1) &#x3D;O(n)</p><p>修改：从头开始遍历，找到要修改的元素位置</p><p>先查找，再插入 O(n)+O(1) &#x3D;O(n)</p><p>删除：从头开始遍历，找到要删除的元素位置</p><p>先查找，再插入 O(n)+O(1) &#x3D;O(n)</p><p>再尾节点留空，备胎。有的节点也是指向最后一个元素的，这样插入时时间复杂度为O(1)。</p><p><strong>数据结构离不开内存的</strong></p><h3 id="5-1-Doubly-linked-list与Circular-linked-list含义以及复杂度分析举例"><a href="#5-1-Doubly-linked-list与Circular-linked-list含义以及复杂度分析举例" class="headerlink" title="5-1.Doubly linked list与Circular linked list含义以及复杂度分析举例"></a>5-1.Doubly linked list与Circular linked list含义以及复杂度分析举例</h3><blockquote><p>1 双链表</p></blockquote><p>双链表，杂交 ，每个节点有3个块：pre val next；</p><p>双链表时间复杂度，头尾O(1),中间O(n)</p><blockquote><p>2循环列表</p></blockquote><p>循环列表 ，对于单链表，尾部指针指向头节点。</p><p> 对于双链表，头pre指向尾，尾next指向头节点。</p><p>其时间复杂度和双链表一样。</p><h3 id="5-2-举例以及题外话"><a href="#5-2-举例以及题外话" class="headerlink" title="5-2.举例以及题外话"></a>5-2.举例以及题外话</h3><p>单链表：学生报名，派对人来的顺序。</p><p>双向链表：浏览器上面标签栏快进，后退。</p><h3 id="6-0-Hash"><a href="#6-0-Hash" class="headerlink" title="6-0.Hash"></a>6-0.Hash</h3><blockquote><p>1）散列算法，哈希函数？</p></blockquote><p>这两个词语是一个意思。这是把一样东西通过函数计算得到另一样东西过程。把明文加密的过程叫做hash function哈希函数，比如八路军过城门检查。</p><blockquote><p>2）什么哈希碰撞？有什么例子？</p></blockquote><p>通过某种验证方式是得到你的哈希值和已有的哈希值一样。</p><p>例子：就像人在囧途 两人票一样，身份证一样，特工伪装完一样的这种感觉。</p><blockquote><p>3）单向散列函数？应用？</p></blockquote><p>明文加密得到密文，但是把你不能通过计算用密文得到我的明文。</p><p>应用1：网盘秒上传功能。你的文件要上传，网盘会拿你的该文件的哈希值，通过某种函数与服务器上存储的哈希值匹配，如果碰撞上，证明你的文件我的服务器上也存在，这时候我只需要复制一份文件的地址给你就欧克了。</p><p>应用2：苹果验证sha验证下载的文件是不是正版；</p><h3 id="6-1-Hash-Table或Hash-Map的原理与复杂度分析"><a href="#6-1-Hash-Table或Hash-Map的原理与复杂度分析" class="headerlink" title="6-1.Hash Table或Hash Map的原理与复杂度分析"></a>6-1.Hash Table或Hash Map的原理与复杂度分析</h3><blockquote><p>1）什么是哈希表？&lt;key,value&gt;？发生哈希碰撞咋办？</p></blockquote><p>hash table and hash map是一个东西。把key通过哈希函数计算得到一个内存地址，再把value放到该地址中。这种设计就是哈希表。如果两个key计算得到的内存地址一样，那么可以用拉链法，再哪个地址中存一个链表的首地址。而链表的每一个节点有两部分。一个放value，一个放key的地址。</p><blockquote><p>2）哈希表时间复杂度？</p></blockquote><p>平均O(1)</p><p>最差O(n) ，因为发生哈希碰撞，可能要以链表的形式存储。</p><blockquote><p>3）扩展？</p></blockquote><p>理解编程语言中hash table的实现，java，python，js。。。。</p><h3 id="7-0-Stack堆栈原理的实际用途与时间复杂度分析"><a href="#7-0-Stack堆栈原理的实际用途与时间复杂度分析" class="headerlink" title="7-0.Stack堆栈原理的实际用途与时间复杂度分析"></a>7-0.Stack堆栈原理的实际用途与时间复杂度分析</h3><blockquote><p>1）栈？堆栈？</p></blockquote><p>一个东西，push与pop不就是堆叠的过程。</p><p>什么是栈？打工刷盘子就能理解？</p><p>你去打工，你是洗盘子的，服务员是取盘子用的。</p><p>用途？</p><p>剪贴板，撤销，浏览器的历史记录；</p><p>栈的时间复杂度？</p><p>push O(1)</p><p>pop O(1)</p><p>查看（peek）某个元素 栈顶O( 1) ,剩余的元素O(n)</p><h3 id="8-0-Queue原理实际应用与时间复杂度分析"><a href="#8-0-Queue原理实际应用与时间复杂度分析" class="headerlink" title="8-0.Queue原理实际应用与时间复杂度分析"></a>8-0.Queue原理实际应用与时间复杂度分析</h3><blockquote><p>1）队列？取票？（FIFO）<br>队列，就是元素先来先操作，后来后操作。</p></blockquote><p>比如你去排队取你的火车票，你排在最前面，工作人员肯定先给你办理，你来的最晚，那你就排在最后面慢慢等着。</p><blockquote><p>2）用什么实现？空间复杂度？时间复杂度？</p></blockquote><p>空间复杂度为O(n);</p><p>链表：删除，插入时间复杂度为 o(1)</p><p>查找：O(n)</p><p>数组：查找O(1)，增加O(1),删除O(n)</p><blockquote><p>3)应用</p></blockquote><p>在系统中应用广泛。</p><p>比如计算机网络中的缓存网络数据包，我们电脑中后台进程管理。</p><blockquote><p>4)思考最差和平均的出现？！！！！！</p></blockquote><p>我觉得是所操作元素的位置决定，而不是所用的是链表还是数组的原因。</p><h3 id="9-0-Tree树的含义以及术语"><a href="#9-0-Tree树的含义以及术语" class="headerlink" title="9-0.Tree树的含义以及术语"></a>9-0.Tree树的含义以及术语</h3><blockquote><p>1)什么是树？</p></blockquote><p>树就是我们的家谱。</p><blockquote><p>2)理解什么是节点，根节点，子节点，叶子节点，兄弟节点，子树，边，高度，深度？等级？</p></blockquote><p>节点：家谱中的所展现的每个人；</p><p>根节点：最上面的人，你的太上老爷这种感觉；</p><p>子节点：根下面的都是子节点，或者是相对于你爸爸，你就是子节点；</p><p>兄弟节点：一个爹生下来的孩子，是兄弟；</p><p>子树：族谱中你爸爸和及它的孩子们就相当于一个子树；</p><p>高度：假如你是你们家族最新的一代人，相对于你（叶子节点）而言，上面还有几代人；</p><p>深度：上帝视角，别人看你家族谱，嗯~你家有n代人（包括你这代）；</p><p>等级：家谱中的每代人；</p><h3 id="9-1-Tree的应用"><a href="#9-1-Tree的应用" class="headerlink" title="9-1.Tree的应用"></a>9-1.Tree的应用</h3><blockquote><p>树就是用来表示层级关系的；</p></blockquote><p>例子：</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line">公司职位表；</span><br><span class="line">windows的文件管理器中的层级结构；</span><br><span class="line">linux中的命令；</span><br><span class="line">html语言的代码；</span><br><span class="line">搜索引擎存储网页结构；</span><br><span class="line">制作IDE 的语法分析 表述语法树；</span><br><span class="line">决策树；</span><br><span class="line">软件的导航栏（菜单栏）</span><br></pre></td></tr></table></figure><h3 id="9-2-常见树种类"><a href="#9-2-常见树种类" class="headerlink" title="9-2.常见树种类"></a>9-2.常见树种类</h3><blockquote><p>0）二叉树：每个节点最多有2个节点；</p></blockquote><blockquote><p>1） prefect binary tree</p></blockquote><p>完美二叉树：同深度的叶子节点都为2</p><p><img src="../Data-Structure-and-algorithm/%E5%AE%8C%E7%BE%8E%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完美二叉树"></p><blockquote><p>2）amost prefect binary tree</p></blockquote><p>完全二叉树：所有的叶子节点不在同一深度上，且最深的一层所在的叶子节点必须连接在最左边的分支上。</p><p><img src="../Data-Structure-and-algorithm/%E5%AE%8C%E5%85%A8%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="完全二叉树"></p><blockquote><p>3）balance binary tree（AVL）</p></blockquote><p>平衡二叉树：每个节点所在子树中的左右分支中最大高度差为1。</p><p><img src="../Data-Structure-and-algorithm/%E5%B9%B3%E8%A1%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="平衡二叉树"></p><p>计算方法： 比如</p><p>节点1： 左右子树差为 3-3 &#x3D;0；</p><p>节点2： 左右子树差为 2-1 &#x3D;1；</p><p>节点4： 左右子树差为1-0&#x3D;1；</p><blockquote><p>4）full binary tree</p></blockquote><p>满二叉树：每层的叶子节点不是满的(2的倍数)。</p><p><img src="../Data-Structure-and-algorithm/%E6%BB%A1%E4%BA%8C%E5%8F%89%E6%A0%91.png" alt="满二叉树"></p><h3 id="9-3-树的进一步研究"><a href="#9-3-树的进一步研究" class="headerlink" title="9-3.树的进一步研究"></a>9-3.树的进一步研究</h3><blockquote><p>1）平衡二叉树，满二叉树的时间复杂度？怎么理解？</p></blockquote><p>空间：O(N)</p><p>搜索：O(log n)<br>插入：O(log n)<br>删除：O(log n)</p><blockquote><p>2）为什么插入是O(log n)?其他的也是同理。</p></blockquote><p>首先最重要的是树的结构，要满足是平衡二叉树或者呢满二叉树。 比如在4的左子树插入8。那么先经过1，然后砍一半，只看节点2，把3所在的子树删除了。然后再2处再砍一半，只看节点4,然后再4的左边插入8。这样的，每次砍一半，看了左半边，就不看右半边。<code>（这里注重的是每次只砍一半的感觉，不要在意为什么要在4处插入，为什么只看左子树。）</code></p><blockquote><p>3）提及其它树？自己分析。</p></blockquote><p>普通二叉树 。时间复杂度O(n)</p><p>堆：O(log n)</p><p>线段树，区间查询 ，修改 O(log n)</p><p>字典树：O(m)m是键的长度。</p><p>图：邻接表，邻接矩阵。</p><h3 id="9-4-Graph图的含义以及举例"><a href="#9-4-Graph图的含义以及举例" class="headerlink" title="9-4.Graph图的含义以及举例"></a>9-4.Graph图的含义以及举例</h3><blockquote><p>1）图？顶点？边？</p></blockquote><p>表示关系</p><p>顶点：就是图中的节点</p><p>边：有方向的线。边必须有方向。</p><blockquote><p>2）有向图，无向图，循环图，无环图？例子？</p></blockquote><p>有向图：有箭头指向的图</p><figure class="highlight plaintext"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">例如：  </span><br><span class="line">飞机从某地到某地有没有航班。</span><br><span class="line">B站用户相互关注情况。</span><br><span class="line">铁路某地到某地有没有铁路段。</span><br></pre></td></tr></table></figure><p>无向图：无箭头指向的图，但也是表示这是连接关系。虽然没有箭头。</p><p>循环图：有至少三个节点连接成环，形成了一个循环的周期</p><p>无环图：没有形成环的图</p><p><strong>注意：树就是特殊的图</strong></p><p>3）邻接表，邻接矩阵？</p><p>邻接表：链表。</p><p>邻接矩阵：数组。</p><h3 id="9-5-其他的图以及时间复杂度"><a href="#9-5-其他的图以及时间复杂度" class="headerlink" title="9-5.其他的图以及时间复杂度"></a>9-5.其他的图以及时间复杂度</h3><p>连通图：节点（V）边（E）遍历时间复杂度：O(v+e)</p><p>其他的树时间复杂度可能与之不同。因为树的种类太多了。难以一一分析。</p><p>扩展知识： 最小生成树，最短路径算法。。。领域不同，所需要了解的深度不同。</p><p>图最坏的时间复杂度为O(v+e)。</p><p>人工智能，计算机图形学 研究图的。</p><h3 id="9-6-总结"><a href="#9-6-总结" class="headerlink" title="9-6.总结"></a>9-6.总结</h3><p>维基百科看看，数据结构有多么的多，讲不完的。</p><blockquote><p>程序员不是全知全能的。</p></blockquote><blockquote><p>要学会这个东西的含义，在那个领域，特性。如何分析？实际应用，有什么例子。</p></blockquote><blockquote><p>想要成功，必须合作。</p></blockquote><blockquote><p>数据结构记得在leecode上定时刷题</p></blockquote>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer </tag>
            
            <tag> program </tag>
            
            <tag> data Structure and alagorithm </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Random habits</title>
      <link href="/blog/2023/08/23/Random-habits/"/>
      <url>/blog/2023/08/23/Random-habits/</url>
      
        <content type="html"><![CDATA[<h2 id="1-习惯的定义及其在日常生活中的重要性"><a href="#1-习惯的定义及其在日常生活中的重要性" class="headerlink" title="1. 习惯的定义及其在日常生活中的重要性"></a>1. 习惯的定义及其在日常生活中的重要性</h2><p>习惯，一个我们每天都在经历但可能没有深入思考的词汇。当我们谈论习惯时，我们是指什么？按照词典的定义，习惯是“经常重复的或通常做的行为，或者是一个人经常做的特定方式”。简单来说，它是我们不经意之间的、经常做的行为。</p><p>但在更深层次上，习惯不仅仅是重复的行为。它是我们身份的一部分，决定我们如何思考、行动和与世界互动。有人曾经说过：“<strong>我们首先塑造我们的习惯，然后我们的习惯塑造我们</strong>。”确实，这些看似微小的日常行为，当累积起来，将决定我们的健康、财务、关系和生活满意度。</p><p>在我们的日常生活中，习惯的重要性不言而喻。考虑一下你的日常例程。你早上起床后第一件事是什么？是刷牙、喝杯水、还是查看手机上的通知？这些日常的选择，不论大小，都构成了你生活的基础。而随着时间的推移，好的习惯可以为我们铺设成功之路，而坏的习惯则可能导致失败或滞后。更重要的是，习惯不仅影响个人。它们也塑造了文化、社区和国家。当一个社区鼓励阅读和终身学习的习惯时，它可能会产生更多的知识型人才。而一个鼓励环保和节约的国家，可能会更有可能保持其自然资源和环境的完好。</p><p>因此，理解习惯的定义和它们在日常生活中的重要性，对于我们每个人来说都是至关重要的。在接下来的部分中，我们将更深入地探讨习惯的形成、如何改变习惯，以及习惯与我们身份的关系。</p><h2 id="2-习惯的形成"><a href="#2-习惯的形成" class="headerlink" title="2. 习惯的形成"></a>2. 习惯的形成</h2><p>在深入探索人类行为的广阔领域中，习惯的机制引起了我的浓厚兴趣。与其说习惯是简单的行为重复，不如说它是对复杂心理和社会动态的反应。让我们从某种角度审视这一现象。</p><p>首先，习惯并不是孤立存在的。它们是由连续的因果链条组成的。首先，我们遇到了一个“触发”。这可能是一个外部的情境，例如看到一家咖啡店，或是一个内部的情感，如感到疲倦。这个触发会启动我们的内部程序，驱使我们进行下一步行动。</p><p>接下来是“例行公事”，一个自动化的行为响应。拿上面的例子来说，感到疲倦可能会驱使你进入咖啡店并购买一杯咖啡。这一步并不需要深思熟虑，因为你的大脑已经为此建立了一个快捷方式。</p><p>最后，每一次行为都会带来某种“奖励”。在这个场景中，咖啡给你带来了清醒和满足感，这种奖励使得你下次再次感到疲倦时更有可能再次选择喝咖啡。</p><p>然而，要注意，这个循环并不是固定不变的。环境的微小变化、我们的内部情绪和其他无数因素都可能影响它。尽管如此，一旦习惯被形成，它会成为一种强大的力量，驱使我们的行为并塑造我们的日常生活。</p><p>当然，这只是习惯背后的一种简化模型。人类行为的复杂性和丰富性远远超出了这三个步骤的描述。但这个模型为我们提供了一个有用的框架，帮助我们理解习惯如何开始、如何维持，以及如何改变。</p><p>举例说明：尼古拉斯的故事</p><p>尼古拉斯，一个中年经济学家，每天上午10点都会离开他的办公桌，步行到公司楼下的小便利店，买一块巧克力饼干，然后回到办公室。这成了他的日常例行公事，他几乎不再对此加以思考。</p><p>1)触发: 尼古拉斯发现，每天上午10点左右，他都会开始感到无聊和疲惫，这是他习惯循环的触发。他需要一个休息，一个改变，或是任何东西来中断这种状态。</p><p>2)例行公事: 他选择下楼到便利店。尽管初衷是为了休息，但他的大脑很快将这种行为与购买巧克力饼干联系起来。每次走进便利店，尼古拉斯都会被那熟悉的甜点柜台吸引。</p><p>3)奖励: 当尼古拉斯回到办公室并吃下那块饼干时，他会感到暂时的满足和快乐。这短暂的奖励感使他在第二天同一时间再次感到冲动，重复这一行为。</p><p>但这种习惯对尼古拉斯的健康有害。几个月后，他注意到他的体重增加了，而且他并没有真正从这种习惯中获得长期的满足感。为了打破这种习惯，尼古拉斯决定深入分析这一习惯循环。他意识到，他实际上并不真的渴望巧克力饼干，他只是需要一个简短的休息。</p><p>于是，他开始试验新的例行公事：当10点的触发出现时，他开始出去散步或与同事聊天。几周后，尼古拉斯发现他不再渴望巧克力饼干。他找到了一种新的方式来满足他的需求，并得到了奖励——与人建立联系或得到新鲜空气，而不是糖分。</p><p>尼古拉斯的故事是一个简单的例子，说明了习惯是如何形成的，以及如何通过理解习惯循环。</p><p>如果我们从神经科学视角分析的话，就可以探索习惯的本质。毕竟，大脑是我们所有行为的中心，习惯自然也不例外。让我们通过一个微观的透视，试图理解习惯在神经层面上的操作机制。位于大脑中部的基底节是一个相对较为古老的部分，它在习惯形成中起着核心作用。为什么一个如此古老的大脑区域会掌管如此现代、复杂的行为过程呢？<strong>答案可能源于经济性</strong>。</p><p>想象一个初次学习开车的人。他必须专注地处理每一个操作，每一个按钮，每一个动作。但随着时间的推移，这些行为变得自动化。为什么？这是因为大脑正在努力降低能量消耗，将复杂的行为简化为可以轻松重复的例行公事。基底节在此过程中发挥着关键作用，帮助大脑“节省”能量。</p><p>当我们在日常生活中遇到一个已知的触发时，基底节会自动“提取”与之相关的例行公事，并为我们执行。这种自动化确保了我们可以在不投入太多认知资源的情况下完成任务。但这也带来了一个问题：习惯一旦形成，就难以改变。</p><p>当然，理解基底节如何在习惯形成中发挥作用，只是对这一复杂过程的一个简化解释。但它为我们提供了一个启示：如果我们想要改变习惯，我们不仅需要意识到它，还需要理解它在神经层面上的操作方式。  </p><p>这种对习惯深层次的理解和分析，提醒我们，尽管我们的行为在很大程度上受到了我们的神经结构的影响，但通过深入的理解和刻意的努力，我们仍然有能力改变这些行为模式，使其更加符合我们的长期目标和愿景。</p><h2 id="3-改变习惯的策略"><a href="#3-改变习惯的策略" class="headerlink" title="3. 改变习惯的策略"></a>3. 改变习惯的策略</h2><p>习惯的本质和形成方式常常被误解。传统上，我们常常认为习惯是可以从零开始培养的。但更深入的认识告诉我们，习惯实际上并非被“养成”，而是被“替换”。每天，自动化的习惯行为充斥着我们的生活，节省了大量的认知资源。但当我们决心改变某种习惯时，单纯地增加新的行为往往不够。旧习惯的触发机制和奖励机制已经深深植根。因此，策略性地“替换”习惯成为关键。</p><p>要成功替换一个习惯，首先需明确其触发机制，再找出新的应对行为，并确保此新行为也带有奖励机制，从而加强新习惯的形成。这种策略性的替换意味着我们需要深入挖掘习惯背后的动机，并有针对性地进行调整。</p><p>在习惯形成与调整的过程中，BJ Fogg和James Clear为我们提供了两个非常有力的策略。</p><p>1)BJ Fogg</p><p>BJ Fogg的微小习惯理论为我们展示了如何利用我们日常的习惯作为习惯形成的基石。他的观点是，人们常常失败于建立新习惯，是因为他们设定的目标过于宏大，导致难以坚持。而将目标分解成更小、更具体的行动，就能更容易地开始和坚持下去。例如，想要培养锻炼的习惯，不必一开始就决心每天锻炼一小时。而是可以从每天做5分钟的拉伸开始，这个小目标既容易实现，也容易培养自信和动力。一旦这个微小的习惯稳固下来，再逐步增加难度和时间。</p><p>更为巧妙的是，Fogg提议，为了更好地保持习惯的连续性，可以尝试将新习惯与某个已有的日常活动连接起来，称为“锚点”。这样，每次执行那个日常活动时，就会自然而然地想到新习惯。例如，每天吃完早餐后进行短暂的冥想，或是在刷牙前进行几分钟的深呼吸。这种策略确保新习惯能够融入我们的日常生活，而不是变成另一个需要额外努力去记住的任务。</p><p>废话少说，上你们最喜欢的案例故事。</p><p>艾米丽是一名软件开发工程师，每天都面临着代码的挑战。由于长时间坐在电脑前，她的身体状况开始逐渐下滑，特别是背部和颈部经常感到酸痛。她明白，定期的运动能够缓解她的这些问题，所以她多次尝试建立锻炼的习惯。</p><p>最初，她买了一个健身房的年卡，打算每天下班后去健身房锻炼一小时。但很快她发现，由于工作压力和项目的突发状况，她经常需要加班，经常错过了健身房的营业时间。那张昂贵的年卡最终成为了一个装饰。</p><p>之后，艾米丽尝试在家做瑜伽。她购买了瑜伽垫和一套教程，希望每天晚上在家练习半小时。然而，每当她结束一天繁重的编程工作，回到家，她经常选择放松地躺在沙发上看电视，而那块瑜伽垫尘封在角落。</p><p>在艾米丽尝试多种方法失败后，她曾幻想过能不能通过她最喜欢的Nintendo Switch游戏来锻炼身体。毕竟，作为一名程序员，电子游戏是她的另一大爱好。她听说过一款名为《健身环大冒险》的游戏，玩家在游玩过程中需要进行各种身体活动来驱动游戏进程。充满期待地，她购买了这款游戏和配套的健身环。最初，她确实非常投入，每天晚上玩一两个小时，全身出汗。但不久，工作和其他娱乐活动开始挤占她的时间，使得玩游戏的频率逐渐减少。再加上随着关卡的增加，游戏难度也逐步上升，需要的体力和耐心都在增加。最终，这个方法又成为了另一个未能坚持的尝试。（所以为什么我说计划无用，只有找到根源才能解决问题）</p><p>失败了三次，艾米丽开始感到灰心。她感觉自己就是那种无法建立健身习惯的人。直到一次偶然的机会，她询问了我……</p><p>考虑到自己每天都需要长时间坐在电脑前工作，她选择了一个简单的习惯：每编写完一个代码模块，就起身做五分钟的伸展运动。这五分钟的锻炼很容易融入她的工作日常，不需要额外的设备，也不需要特别调整时间。作为“锚点”，她设置了电脑上的提醒。每次完成一个任务，电脑会提醒她起身伸展。</p><p>几周下来，这个微小习惯真的起到了效果。不仅如此，她还发现自己的工作效率有所提高，因为这短暂的运动能够缓解眼睛和大脑的疲劳，让她更有精神地投入到下一个任务中。这个微小的改变，帮助艾米丽不仅改善了身体状况，也让她的编程生活变得更为健康和有序。</p><p>2）James Clear </p><p>James Clear的习惯策略为我们揭示了成功养成和坚持习惯的三大秘诀：明确性、吸引力和执行的简易性。</p><p>明确性：不确定性是习惯失败的罪魁祸首。只有当我们为自己设定清晰、具体的目标，例如“每天早上7点跑步30分钟”，我们才能避免拖延，确保每天都有明确的行动方向。</p><p>吸引力：习惯不仅仅是行动，它更是一种身份的体现。当我们将某个习惯与自己的核心身份相联系，这个习惯就不再是单纯的任务，而是身份的一部分。这是一种强大的心理转变。Clear建议的“我是跑者”而不仅仅是“我要跑步”，为我们提供了一种深层次的动机和吸引力，将习惯和自身价值观紧密连接。</p><p>执行的简易性：开始总是最难的，但Clear坚信一旦开始，其后续的过程就会更容易。他强调从微小的行动开始，像“做一次俯卧撑”，这种简单的启动行为会为习惯的持续创造动力，就像滚动的雪球，开始虽小，但动量会随着时间而增长。</p><p>然而我们艾米莉的故事还没有结束。</p><p>在尝试了许多方法后，艾米莉终于成功地采用了BJ Fogg的微小习惯理论。但她知道，养成习惯并不仅仅是开始，更重要的是坚持下去。这时，她读到了James Clear的《原子习惯》，并从中吸取了许多宝贵的启示（当然阅读这时候也替换掉了她平时打游戏的时间）</p><p>艾米莉重新审视了自己的锻炼目标。之前，她总是告诉自己：“我要变得更健康”，但这太过宽泛。受到Clear的启示，她改变了策略，为自己设定了明确的目标：“我要每天早上7点进行30分钟的有氧运动。” 这个明确的目标给了她每天的方向和焦点。</p><p>为了使锻炼更加吸引人，艾米莉决定将其与自己的身份联系起来。她开始自我激励：“我是一个程序员，但我也是一个跑者。”这样的身份认同让她每次面对“是否要运动”的选择时，更容易坚持下去。艾米莉知道，为了确保习惯的持续，她需要简化自己的锻炼过程。她决定从最简单的开始，每天做几次深蹲和俯卧撑。只要开始，后续的运动就像雪球效应，自然而然会跟随。几个月过去了，艾米莉的日常已经完全改变。每天早上，她按时起床，准时开始她的运动。她不再依赖Switch游戏或其他复杂的策略，因为她已经找到了自己的运动节奏。而更让她惊喜的是，她的编程效率也随之提高了，她觉得每天早上的锻炼给了她清晰的头脑和充沛的精力。在经历了许多失败后，艾米莉终于找到了适合自己的习惯养成策略，她深知，成功的秘诀不在于开始，而在于持续和策略。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Python Numpy</title>
      <link href="/blog/2023/08/20/Python-Numpy/"/>
      <url>/blog/2023/08/20/Python-Numpy/</url>
      
        <content type="html"><![CDATA[<h2 id="Numpy介绍"><a href="#Numpy介绍" class="headerlink" title="Numpy介绍"></a>Numpy介绍</h2><p>NumPy是Python语言的一个扩展程序库。支持高阶大规模的多维数组与矩阵运算，此外也针对数组运算提供大量的数学函数函式库。</p><p>针对金融领域的大量矩阵运算，Numpy模块中存储多维数据、处理大型矩阵、开展随机抽样等复杂计算的功能可以完美解决金融领域许多复杂的问题。正如Numpy的random模块可以解决金融量化分析与风险管理过程中涉及基于某种分布的随机抽样，Numpy的financial模块可以测算现金流终值、现值、内含报酬率等金融问题。因此本章主要结合金融场景有的放矢地对Numpy的操作进行介绍和演示。</p><p><img src="../Python-Numpy/Numpy%E4%BB%8B%E7%BB%8D.png" alt="Numpy介绍"></p><h2 id="Numpy操作"><a href="#Numpy操作" class="headerlink" title="Numpy操作"></a>Numpy操作</h2><h3 id="1-导入numpy与检查版本"><a href="#1-导入numpy与检查版本" class="headerlink" title="1.导入numpy与检查版本"></a>1.导入numpy与检查版本</h3><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy <span class="keyword">as</span> np    <span class="comment">#导入NumPy模块</span></span><br><span class="line"><span class="built_in">print</span>(np.__version__)    <span class="comment">#查看NumPy版本信息</span></span><br></pre></td></tr></table></figure><p>这里我导入Numpy模块后将其命名为np，后续使用就基于这个命名进行。另外，我这里使用的Numpy版本是1.24.3，不同版本可能会有细微差异，不过应该不会影响使用。</p><h3 id="2-创建数组"><a href="#2-创建数组" class="headerlink" title="2.创建数组"></a>2.创建数组</h3><p>创建数组的方式有很多，这里简单介绍几种</p><h5 id="1-直接输入法"><a href="#1-直接输入法" class="headerlink" title="1.直接输入法"></a>1.直接输入法</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">a_array = np.array(一个列表)    <span class="comment">#一维数组</span></span><br><span class="line">b_array = np.array([列表<span class="number">1</span>，列表<span class="number">2</span>，...，列表n])    <span class="comment">#二维数组</span></span><br></pre></td></tr></table></figure><p>这两种方式都可以建立数组，不过常用的数组基本都不超过二维，因此直接输入法在很多场景用途都非常广泛。</p><h5 id="2-方法生成数组"><a href="#2-方法生成数组" class="headerlink" title="2.方法生成数组"></a>2.方法生成数组</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line">np.arange(start,stop,step)    <span class="comment">#返回一个有终点和起点的固定步长的排列</span></span><br><span class="line">np.linspace(start,stop,num)    <span class="comment">#生成一个指定大小，指定数据区间的均匀分布序列</span></span><br><span class="line">np.zeros((m,n))    <span class="comment">#返回一个给定形状和类型的用0填充的数组</span></span><br><span class="line">np.ones((m,n))    <span class="comment">#返回一个给定形状和类型的用1填充的数组</span></span><br><span class="line">np.eye(N)    <span class="comment">#创建一个指定形状参数的单位矩阵数组</span></span><br></pre></td></tr></table></figure><p>当然，通过不同方法创建的数组应用场景也会不同。在金融领域，这几个方法是比较常用的，可以迅速生成自己需要的数组。（亲测非常的好用hh）</p><h5 id="3-将列表转化为数组"><a href="#3-将列表转化为数组" class="headerlink" title="3.将列表转化为数组"></a>3.将列表转化为数组</h5><p>有些时候，数据都用列表进行存储，这时候我们就需要通过列表转化为数组，从而使用Numpy模块进行金融分析。</p><p>我们常用的方法主要有三个：</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">np.array(listname)    <span class="comment">#将列表转化为数组</span></span><br><span class="line">arrayname.resize(m,n)    <span class="comment">#改变数组形状</span></span><br><span class="line">arrayname.ravel()    <span class="comment">#数组降维</span></span><br></pre></td></tr></table></figure><p>数组中的数据在内存里是固定的，但计算时的排列方式却可以随时更改，这也是数组的强大之处。</p><p>值得说的一点，<code>reshape</code>函数和<code>resize</code>函数功能相同，都可以修改数组的形状，区别是前者返回新数组，后者则直接修改原始数组。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">arraynew = arrayord.reshape(m,n)    <span class="comment">#修改数组形状</span></span><br></pre></td></tr></table></figure><h3 id="3-数组属性"><a href="#3-数组属性" class="headerlink" title="3.数组属性"></a>3.数组属性</h3><p>好了，说了这么多，那我们应该怎么查看数组的信息呢？下面我列出了一些比较常用的方法，非常的基础。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br></pre></td><td class="code"><pre><span class="line"><span class="built_in">type</span>(arrayname)    <span class="comment">#显示NumPy数组类型</span></span><br><span class="line">arrayname.dtype    <span class="comment">#显示数组元素的类型</span></span><br><span class="line">arrayname.size    <span class="comment">#显示数组元素的个数</span></span><br><span class="line">arrayname.shape     <span class="comment">#显示数组的形状（行数，列数）</span></span><br><span class="line">arrayname.ndim     <span class="comment">#显示数组的维度</span></span><br></pre></td></tr></table></figure><p>数组的类型：<code>&lt;class &#39;numpy.ndarray&#39;&gt;</code>（其实，我也不知道ndarray是啥意思，可能是n维数组（？））</p><p>查看ndarray支持的数据类型可访问：<a href="https://numpy.org/devdocs/user/basics.types.html%EF%BC%88%E8%BF%99%E6%98%AFnumpy%E7%9A%84%E5%AE%98%E7%BD%91%EF%BC%8C%E6%94%BE%E5%BF%83%E8%BF%9B%EF%BC%89">https://numpy.org/devdocs/user/basics.types.html（这是numpy的官网，放心进）</a></p><p>后面那三个方法就没啥好说的，很容易理解。</p><h3 id="4-数组操作"><a href="#4-数组操作" class="headerlink" title="4.数组操作"></a>4.数组操作</h3><h5 id="1-切片-索引-排序"><a href="#1-切片-索引-排序" class="headerlink" title="1.切片,索引,排序"></a>1.切片,索引,排序</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">arrayname[start:end:step,start:end:step]    <span class="comment">#二维数组的切片</span></span><br><span class="line">arrayname[m,n]    <span class="comment">#二维数组的索引</span></span><br><span class="line">np.sort(arrayname,axis = <span class="number">0</span>/<span class="number">1</span>)    <span class="comment">#数组的排序</span></span><br></pre></td></tr></table></figure><p>这三个操作就非常的基本了，切片、索引、排序三个常用方法。类似于python列表的操作，但有一点点不一样。</p><p>主要的不同是<code>sort</code>函数，<code>axis</code>参数可以通过坐标轴设定来改变排序方法，<code>axis=1</code>表示横向操作，<code>axis=0</code>表示纵向操作。不输入参数时，默认按行进行排序。</p><h5 id="2-合并数组"><a href="#2-合并数组" class="headerlink" title="2.合并数组"></a>2.合并数组</h5><p>在金融分析的时候，我们有时候还需要对不同的数组进行合并，从而达到整合数据的目的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line">np.append(array_one,array_two)    <span class="comment">#合并两个数组</span></span><br><span class="line">np.concatenate([数组<span class="number">1</span>],[数组<span class="number">2</span>],...,[数组n])    <span class="comment">#合并多个数组</span></span><br></pre></td></tr></table></figure><p>这两个方法都可以对数组进行合并。不同的是，append函数默认是对行进行合并，concatenate函数默认对列进行合并。（append函数使用之后可能会导致数组退化为一维数组）</p><h5 id="3-数组计算"><a href="#3-数组计算" class="headerlink" title="3.数组计算"></a>3.数组计算</h5><p>不多废话，直接上方法</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">arrayname.<span class="built_in">sum</span>()    <span class="comment">#对每个数组的元素求和</span></span><br><span class="line">arrayname.<span class="built_in">min</span>()    <span class="comment">#求数组的元素最小值</span></span><br><span class="line">arrayname.<span class="built_in">max</span>()    <span class="comment">#求数组元素的最大值</span></span><br><span class="line">arrayname.prod()    <span class="comment">#求数组内部元素的乘积</span></span><br><span class="line">arrayname.mean()    <span class="comment">#求数组元素的均值</span></span><br><span class="line">arrayname.var()    <span class="comment">#求数组元素的方差</span></span><br><span class="line">arrayname.std()    <span class="comment">#求数组元素的标准差</span></span><br></pre></td></tr></table></figure><p>这几个是最常用的方法，默认是对所有元素进行操作。当然，我们也可以通过设置<code>axis参数</code>让它只针对行列进行操作。</p><p>下面是数组之间的计算方法，可以类比普通计算方法。这部分内容还是比较通俗易懂的。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">array_one + array_two    <span class="comment">#数组相加</span></span><br><span class="line">array_one - array_two    <span class="comment">#数组相减</span></span><br><span class="line">array_one * array_two    <span class="comment">#数组相乘</span></span><br><span class="line">array_one / array_two    <span class="comment">#数组相除</span></span><br><span class="line"><span class="built_in">pow</span>(arrayname,n)    <span class="comment">#数组的幂</span></span><br><span class="line">np.dot(array_one,array_two)    <span class="comment">#计算两个数组的点积</span></span><br></pre></td></tr></table></figure><h5 id="4-矩阵操作"><a href="#4-矩阵操作" class="headerlink" title="4.矩阵操作"></a>4.矩阵操作</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">np.corrcoef(arrayname)    <span class="comment">#查看相关系数矩阵</span></span><br><span class="line">np.diag(arrayname)    <span class="comment">#查看矩阵对角线</span></span><br><span class="line">np.triu(arrayname)    <span class="comment">#查看矩阵上三角</span></span><br><span class="line">np.tril(arrayname)    <span class="comment">#查看矩阵下三角</span></span><br><span class="line">np.trace(arrayname)    <span class="comment">#查看矩阵的迹</span></span><br><span class="line">np.transpose(arrayname)    <span class="comment">#查看转置矩阵</span></span><br></pre></td></tr></table></figure><p>同样，都是线性代数的知识，简单略过。</p><h3 id="5-linalg模块"><a href="#5-linalg模块" class="headerlink" title="5.linalg模块"></a>5.linalg模块</h3><p>终于到了linalg子模块的部分了，这个模块主要是用来进行线性代数的工具包。对于金融领域来说，常用的不算很多。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy.linalg <span class="keyword">as</span> la    <span class="comment">#导入linalg模块</span></span><br><span class="line">la.det(arrayname)    <span class="comment">#矩阵行列式</span></span><br><span class="line">la.inv(arrayname)    <span class="comment">#逆矩阵</span></span><br></pre></td></tr></table></figure><p>没错，就这两个方法，可以说关于矩阵的运算，numpy基础库就已经可以解决大部分，很多时候并不需要再引入linalg模块。</p><h3 id="6-random模块"><a href="#6-random模块" class="headerlink" title="6.random模块"></a>6.random模块</h3><p>哈哈哈，这个子模块可是非常常用的。不仅仅是金融领域，在平常的时候，求一些随机数的时候也经常使用。</p><p>random模块主要是通过生成随机种子来创建随机数，而随机种子原理是通过读取用户操作时的时间戳来生成序列。（不过到2038 年 01 月 19 日 03 时 14 分 07 秒就失效了，ee，不知道之后会咋解决这个问题，可能会有大佬想出新的方法？）</p><p>好了，这些大概就是random模块随机的原理，接下来，让我们看看基于特定统计分布的随机取样。</p><table><thead><tr><th align="center">函数名称</th><th align="center">统计分布类型</th></tr></thead><tbody><tr><td align="center">beta</td><td align="center">贝塔分布</td></tr><tr><td align="center">binomial</td><td align="center">二项分布</td></tr><tr><td align="center">chisquare</td><td align="center">卡方分布</td></tr><tr><td align="center">exponential</td><td align="center">指数分布</td></tr><tr><td align="center">f</td><td align="center">F分布</td></tr><tr><td align="center">gamma</td><td align="center">伽马分布</td></tr><tr><td align="center">geometric</td><td align="center">几何分布</td></tr><tr><td align="center">hypergeometric</td><td align="center">超几何分布</td></tr><tr><td align="center">lognormal</td><td align="center">对数正态分布</td></tr><tr><td align="center">normal</td><td align="center">正态分布</td></tr><tr><td align="center">poisson</td><td align="center">泊松分布</td></tr><tr><td align="center">standard_normal</td><td align="center">标准正态分布</td></tr><tr><td align="center">standard_t</td><td align="center">t分布</td></tr><tr><td align="center">rand</td><td align="center">标准均匀分布</td></tr><tr><td align="center">randint</td><td align="center">给定区间内随机抽取整数</td></tr><tr><td align="center">randn</td><td align="center">标准正态分布</td></tr></tbody></table><p>以上就是整理出来的随机抽样分布表。内容非常的多，这里篇幅有限，就简单介绍几个最常用的随机抽样。</p><h5 id="1-基于正态分布的随机抽样"><a href="#1-基于正态分布的随机抽样" class="headerlink" title="1.基于正态分布的随机抽样"></a>1.基于正态分布的随机抽样</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br></pre></td><td class="code"><pre><span class="line">x_norm = npr.normal(mean,std,I)</span><br><span class="line">y_norm = npr.randn(I)</span><br><span class="line">z_norm = npr.standard_normal(I)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运用normal函数抽样的均值：&quot;</span>,x_norm.mean())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运用normal函数抽样的标准差：&quot;</span>,x_norm.std())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运用randn函数抽样的均值：&quot;</span>,y_norm.mean())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运用randn函数抽样的标准差：&quot;</span>,y_norm.std())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运用standard_normal函数抽样的均值：&quot;</span>,z_norm.mean())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;运用standard_normal函数抽样的标准差：&quot;</span>,z_norm.std())</span><br></pre></td></tr></table></figure><p>其中，I代表随机抽样的次数、mean代表均值、std代表标准差。</p><p>经过我的尝试，我觉得运用不同函数从标准正态分布中抽取的随机数，所得到的结果不算很相似。（可能是我运气不好，算出来的结果差别都不小）</p><h5 id="2-基于卡方分布的随机抽样"><a href="#2-基于卡方分布的随机抽样" class="headerlink" title="2.基于卡方分布的随机抽样"></a>2.基于卡方分布的随机抽样</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">chis = npr.chisquare(freedom,I)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;卡方分布的均值：&quot;</span>,chis.mean())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;卡方分布的标准差：&quot;</span>,chis.std())</span><br></pre></td></tr></table></figure><p>其中，I代表随机抽样的次数、freedom代表自由度。</p><h5 id="3-t分布"><a href="#3-t分布" class="headerlink" title="3.t分布"></a>3.t分布</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br></pre></td><td class="code"><pre><span class="line">stan = npr.standard_t(freedom,I)</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t分布的均值：&quot;</span>,stan.mean())</span><br><span class="line"><span class="built_in">print</span>(<span class="string">&quot;t分布的标准差：&quot;</span>,stan.std())</span><br></pre></td></tr></table></figure><p>其中，I代表随机抽样的次数、freedom代表自由度。</p><h3 id="7-现金流模型"><a href="#7-现金流模型" class="headerlink" title="7.现金流模型"></a>7.现金流模型</h3><p>oh，终于到了金融领域的分析模块了。</p><p>先简单介绍一下，针对金融产品的定价方式有3种方法：一是基于现金流贴现的定价方法，二是基于风险与收益的定价方法，三是基于无风险收益的无套利定价方法。其中，现金流贴现方法最为常用。</p><p>接下来，我们需要先安装numpy_financial模块。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">import</span> numpy_financial <span class="keyword">as</span> npf</span><br></pre></td></tr></table></figure><h5 id="1-现金流终值"><a href="#1-现金流终值" class="headerlink" title="1.现金流终值"></a>1.现金流终值</h5><p><img src="../Python-Numpy/%E7%8E%B0%E9%87%91%E6%B5%81%E7%BB%88%E5%80%BC.png" alt="现金流终值"></p><p>现金流的终值是指一定时期内每期期末等额收付款项的复利终值之和。可用fv函数进行计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npf.fv(rate,nper,pmt,pv)</span><br></pre></td></tr></table></figure><p>其中，rate指投资回报率、nper指投资整体期限、pmt指投资期间发生的固定金额现金流、pv指净现金流现值。</p><h5 id="2-现金流现值"><a href="#2-现金流现值" class="headerlink" title="2.现金流现值"></a>2.现金流现值</h5><p><img src="../Python-Numpy/%E7%8E%B0%E9%87%91%E6%B5%81%E7%8E%B0%E5%80%BC.png" alt="现金流现值"></p><p>现金流现值是指一定时期内每期期末收付款项的复利现值之和。可用pv函数进行计算。</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npf.pv(rate,nper,pmt,pv)</span><br></pre></td></tr></table></figure><p>其中，rate指投资回报率、nper指投资整体期限、pmt指投资期间发生的固定金额现金流、pv指净现金流现值。</p><h5 id="3-净现值"><a href="#3-净现值" class="headerlink" title="3.净现值"></a>3.净现值</h5><p>净现值（NPV）通过计算每个投资期间的成本（负现金流）和收益（正现金流）来确定。期限通常为一年，但可以按季度，半年或数月来衡量。在计算每个时期的现金流量后，每个时期的现值（PV）是通过以定期收益率（市场规定的收益率）贴现其未来价值（见公式）来实现的。</p><p><img src="../Python-Numpy/%E5%87%80%E7%8E%B0%E5%80%BC%E5%85%AC%E5%BC%8F.png" alt="净现值公式"></p><p>净现值 &#x3D; 未来现金净流量现值-原始投资额现值</p><p>运用python计算项目的净现值时，可以运用numpy_financial模块的函数npv</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npf.npv(rate, values)</span><br></pre></td></tr></table></figure><p>其中，参数rate代表项目的投资回报率或者贴现率、参数values代表以数组形式输入的期初和存储期每年年末的净现金流。</p><p><strong>内含报酬率</strong>是指能够使未来现金净流量现值等于原始投资额现值的折现率。</p><p>当净现值&#x3D;0时，未来现金净流量现值&#x3D;原始投资额现值。</p><p>运用python计算项目的净现值时，可以运用numpy_financial模块的函数irr</p><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">npf.irr(values)</span><br></pre></td></tr></table></figure><p>其中，参数values代表以数组形式输入的期初和存储期每年年末的净现金流。</p><h5 id="4-等额本息还款"><a href="#4-等额本息还款" class="headerlink" title="4.等额本息还款"></a>4.等额本息还款</h5><figure class="highlight python"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">per = np.array(nper)</span><br><span class="line">npf.pmt(rate, nper, pv)    <span class="comment">#本息还款金额</span></span><br><span class="line">npf.ppmt(rate, per, nper, pv)    <span class="comment">#本息还款本金</span></span><br><span class="line">npf.ipmt(rate, per, nper, pv)    <span class="comment">#本息还款利息</span></span><br></pre></td></tr></table></figure><p>其中，rate指按揭贷款月利率、nper代表贷款的整体期限、pv代表贷款的本金金额、fv代表期末现金流、per代表逐次还款的期限（用数组表示）。</p><h2 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h2><p>综上，Numpy模块是Python在金融领域运用的必备第三方模块。在数据分析方面应用还是很广泛的。后期，我也有可能更新pandas、scipy、matplotlib等模块的金融应用。（maybe）这几个第三方库确实很好用，但是老师上课基本不讲，网络上我也没找到内容和质量好的文章，于是便写了本文。</p>]]></content>
      
      
      <categories>
          
          <category> Program </category>
          
      </categories>
      
      
        <tags>
            
            <tag> program </tag>
            
            <tag> finance </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>VIM</title>
      <link href="/blog/2023/08/19/VIM/"/>
      <url>/blog/2023/08/19/VIM/</url>
      
        <content type="html"><![CDATA[<h2 id="1-vim介绍"><a href="#1-vim介绍" class="headerlink" title="1.vim介绍"></a>1.vim介绍</h2><h3 id="vim编辑器有三种模式："><a href="#vim编辑器有三种模式：" class="headerlink" title="vim编辑器有三种模式："></a>vim编辑器有三种模式：</h3><p>命令模式、编辑模式、末行模式</p><p><strong>模式间切换方法</strong>：<br>（1）命令模式下，输入<code>:</code>后，进入末行模式<br>（2）末行模式下，按<code>esc</code>慢退、按两次<code>esc</code>快退、或者删除所有命令，可以回到命令模式<br>（3）命令模式下，按下<code>i</code>、<code>a</code>等键，可以计入编辑模式<br>（4）编辑模式下，按下<code>esc</code>，可以回到命令模式</p><h3 id="vim打开文件："><a href="#vim打开文件：" class="headerlink" title="vim打开文件："></a><strong>vim打开文件</strong>：</h3><table><thead><tr><th>Vi 使用的选项</th><th>说 明</th></tr></thead><tbody><tr><td>vim filename</td><td>打开或新建一个文件，并将光标置于第一行的首部</td></tr><tr><td>vim -r filename</td><td>恢复上次 vim 打开时崩溃的文件</td></tr><tr><td>vim -R filename</td><td>把指定的文件以只读方式放入 Vim 编辑器中</td></tr><tr><td>vim + filename</td><td>打开文件，并将光标置于最后一行的首部</td></tr><tr><td>vim +n filename</td><td>打开文件，并将光标置于第 n 行的首部</td></tr><tr><td>vim +&#x2F;pattern filename</td><td>打幵文件，并将光标置于第一个与 pattern 匹配的位置</td></tr><tr><td>vim -c command filename</td><td>在对文件进行编辑前，先执行指定的命令</td></tr></tbody></table><h2 id="2-命令模式"><a href="#2-命令模式" class="headerlink" title="2.命令模式"></a>2.命令模式</h2><h3 id="1-光标移动"><a href="#1-光标移动" class="headerlink" title="1.光标移动"></a>1.光标移动</h3><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>jkhl</td><td>基本移动，上下左右</td></tr><tr><td>gg</td><td>光标移动到文档首行</td></tr><tr><td>G</td><td>光标移动到文档尾行</td></tr><tr><td>^或_</td><td>光标移动到行首第一个非空字符</td></tr><tr><td>home键或0或者g0</td><td>光标移动到行首第一个字符</td></tr><tr><td>g_</td><td>光标移动到行尾最后一个非空字符</td></tr><tr><td>end或或者 g 或者g或者<em>g</em></td><td>光标移动到行尾最后一个字符</td></tr><tr><td>gm</td><td>光标移动到当前行中间处</td></tr><tr><td>b&#x2F;B</td><td>光标向前移动一个单词（大写忽略&#x2F;-等等特殊字符）</td></tr><tr><td>w&#x2F;W</td><td>光标向后移动一个单词（大写忽略&#x2F;-等等特殊字符）</td></tr><tr><td>e&#x2F;E</td><td>移到单词结尾（大写忽略&#x2F;-等等特殊字符）</td></tr><tr><td>ctrl+b或pageUp键</td><td>翻屏操作，向上翻</td></tr><tr><td>ctrl+f或pageDn键</td><td>翻屏操作，向下翻</td></tr><tr><td>数字+G</td><td>快速将光标移动到指定行</td></tr><tr><td>&#96;.</td><td>移动到上次编辑处</td></tr><tr><td>数字+上下方向键</td><td>以当前光标为准，向上&#x2F;下移动n行</td></tr><tr><td>数字+左右方向键</td><td>以当前光标为准，向左&#x2F;右移动n个字符</td></tr><tr><td>H</td><td>移动到屏幕顶部</td></tr><tr><td>M</td><td>移动到屏幕中间</td></tr><tr><td>L</td><td>移动到屏幕尾部</td></tr><tr><td>z+Enter键</td><td>当前行在屏幕顶部</td></tr><tr><td>z+ .</td><td>当前行在屏幕中间</td></tr><tr><td>z+ -</td><td>当前行在屏幕底部</td></tr><tr><td>shift+6</td><td>光标移动到行首</td></tr><tr><td>shift+4</td><td>光标移动到行尾</td></tr><tr><td>-</td><td>移动到上一行第一个非空字符</td></tr><tr><td>+</td><td>移动到下一行第一个非空字符</td></tr><tr><td>)</td><td>向前移动一个句子</td></tr><tr><td>(</td><td>向后移动一个句子</td></tr><tr><td>}</td><td>向前移动一个段落</td></tr><tr><td>{</td><td>向前移动一个段落</td></tr><tr><td>count l</td><td>移动到count 列</td></tr><tr><td>counth</td><td>向左移动count 字符</td></tr><tr><td>countl</td><td>向右移动count字符</td></tr><tr><td>countgo</td><td>移动到count字符</td></tr></tbody></table><h3 id="2-选中内容"><a href="#2-选中内容" class="headerlink" title="2.选中内容"></a>2.选中内容</h3><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>v</td><td>进行字符选中</td></tr><tr><td>V 或shift+v</td><td>进行行选中</td></tr><tr><td>gv</td><td>选中上一次选择的内容</td></tr><tr><td>o</td><td>光标移动到选中内容另一处结尾</td></tr><tr><td>O</td><td>光标移动到选中内容另一处角落</td></tr><tr><td>ctr + V</td><td>进行块选中</td></tr></tbody></table><h3 id="3-复制（配合粘贴命令p使用）"><a href="#3-复制（配合粘贴命令p使用）" class="headerlink" title="3.复制（配合粘贴命令p使用）"></a>3.复制（配合粘贴命令p使用）</h3><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>y</td><td>复制已选中的文本到剪贴板</td></tr><tr><td>n+yy</td><td>复制光标所在行，此命令前可以加数字 n，可复制多行</td></tr><tr><td>yw</td><td>复制光标位置的单词</td></tr><tr><td>ctrl+v + 方向键+yy</td><td>ctrl+v，并按方向键选中区块，按下yy复制</td></tr></tbody></table><h3 id="4-剪切"><a href="#4-剪切" class="headerlink" title="4.剪切"></a>4.剪切</h3><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>dd</td><td>剪切<strong>光标所在行</strong></td></tr><tr><td>数字+dd</td><td>以光标所在行为准（包含当前行），<strong>向下剪切指定行数</strong></td></tr><tr><td>D</td><td>剪切光标所在行</td></tr></tbody></table><h3 id="5-粘贴"><a href="#5-粘贴" class="headerlink" title="5.粘贴"></a>5.粘贴</h3><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>p</td><td>将剪贴板中的内容<strong>粘贴到光标后</strong></td></tr><tr><td>P（大写）</td><td>将剪贴板中的内容<strong>粘贴到光标前</strong></td></tr></tbody></table><h3 id="6-删除"><a href="#6-删除" class="headerlink" title="6.删除"></a>6.删除</h3><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>x</td><td>删除<strong>光标所在位置</strong>的字符</td></tr><tr><td>X(大写)</td><td>删除<strong>光标前</strong>一个字符</td></tr><tr><td>dd</td><td>删除<strong>光标所在行</strong>，删除之后，<strong>下一行上移</strong></td></tr><tr><td>D</td><td>删除<strong>光标位置到行尾</strong>的内容，删除之后，<strong>下一行不上移</strong></td></tr><tr><td>ndd</td><td>删除当前行（包括此行）后 n 行文本</td></tr><tr><td>dw</td><td>移动光标到单词的开头以删除该单词</td></tr><tr><td>dG</td><td>删除光标所在行一直到文件末尾的所有内容</td></tr><tr><td>:a1,a2d</td><td>删除从 a1 行到 a2 行的文本内容</td></tr></tbody></table><h3 id="7-撤销-恢复"><a href="#7-撤销-恢复" class="headerlink" title="7.撤销&#x2F;恢复"></a>7.撤销&#x2F;恢复</h3><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>u</td><td>撤销</td></tr><tr><td>ctrl+r</td><td>恢复</td></tr><tr><td>U(大写)</td><td>撤销所有编辑</td></tr></tbody></table><h3 id="8-字符转换"><a href="#8-字符转换" class="headerlink" title="8.字符转换"></a>8.字符转换</h3><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>~</td><td>转换大小写</td></tr><tr><td>u</td><td>变成小写</td></tr><tr><td>U</td><td>变成大写</td></tr></tbody></table><h3 id="9-编辑命令的快捷键"><a href="#9-编辑命令的快捷键" class="headerlink" title="9.编辑命令的快捷键"></a>9.编辑命令的快捷键</h3><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>↑或ctr + p</td><td>上一条命令</td></tr><tr><td>↓或ctr + n</td><td>下一条命令</td></tr><tr><td>ctr + b</td><td>移动到命令行开头</td></tr><tr><td>ctr + e</td><td>移动到命令行结尾</td></tr><tr><td>ctr + ←</td><td>向左一个单词</td></tr><tr><td>ctr + →</td><td>向右一个单词</td></tr></tbody></table><h2 id="3-末行模式-xxx命令"><a href="#3-末行模式-xxx命令" class="headerlink" title="3.末行模式(: xxx命令)"></a>3.末行模式(: xxx命令)</h2><h3 id="1-保存-退出文件操作"><a href="#1-保存-退出文件操作" class="headerlink" title="1.保存&#x2F;退出文件操作"></a>1.保存&#x2F;退出文件操作</h3><table><thead><tr><th>命令</th><th>功能描述</th></tr></thead><tbody><tr><td>:wq</td><td>保存并退出 Vim 编辑器</td></tr><tr><td>:wq!</td><td>保存并强制退出 Vim 编辑器</td></tr><tr><td>:q</td><td>不保存就退出 Vim 编辑器</td></tr><tr><td>:q!</td><td>不保存，且强制退出 Vim 编辑器</td></tr><tr><td>:w</td><td>保存但是不退出 Vim 编辑器</td></tr><tr><td>:w!</td><td>强制保存文本</td></tr><tr><td>:w filename</td><td>另存到 filename 文件</td></tr><tr><td>x！</td><td>保存文本，并退出 Vim 编辑器</td></tr><tr><td>ZZ</td><td>直接退出 Vim 编辑器</td></tr></tbody></table><h3 id="2-查找：“-关键词”"><a href="#2-查找：“-关键词”" class="headerlink" title="2.查找：“&#x2F;关键词”"></a>2.查找：“&#x2F;关键词”</h3><p>在查找结果中，用<code>N</code>、<code>n</code>可以切换上下结果；输入<code>nohl</code>，可以取消高亮</p><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>&#x2F;abc</td><td>从光标所在位置<strong>向前查找</strong>字符串 abc</td></tr><tr><td>&#x2F;^abc</td><td>查找以 abc 为行首的行</td></tr><tr><td>&#x2F;abc$</td><td>查找以 abc 为行尾的行</td></tr><tr><td>?abc</td><td>从光标所在位置<strong>向后查找</strong>字符串 abc</td></tr><tr><td>n或；</td><td>向同一方向重复上次的查找指令</td></tr><tr><td>N或,</td><td>向相反方向重复上次的查找指定</td></tr></tbody></table><h3 id="3-替换"><a href="#3-替换" class="headerlink" title="3.替换"></a>3.替换</h3><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>r</td><td>替换光标所在位置的字符</td></tr><tr><td>R</td><td>从光标所在位置开始替换字符，其输入内容会覆盖掉后面等长的文本内容，按“Esc”可以结束</td></tr><tr><td><code>:s/a1/a2</code></td><td>替换<strong>当前光标所在行第一处</strong>符合条件的内容</td></tr><tr><td><code>:s/a1/a2/g</code></td><td>替换<strong>当前光标所在行</strong>所有的 a1 都用 a2 替换</td></tr><tr><td><code>:%s/a1/a2</code></td><td>替换<strong>所有行</strong>中，<strong>第一处</strong>符合条件的内容</td></tr><tr><td><code>:%s/a1/a2/g</code></td><td>替换<strong>所有行</strong>中，<strong>所有</strong>符合条件的内容</td></tr><tr><td><code>:n1,n2 s/a1/a2</code></td><td>将文件中 <strong>n1 到 n2 行</strong>中<strong>第一处</strong> a1 都用 a2 替换</td></tr><tr><td><code>:n1,n2 s/a1/a2/g</code></td><td>将文件中 <strong>n1 到 n2 行</strong>中<strong>所有</strong> a1 都用 a2 替换</td></tr></tbody></table><h3 id="4-行号显示：“-set-nu”"><a href="#4-行号显示：“-set-nu”" class="headerlink" title="4.行号显示：“: set nu”;"></a>4.行号显示：“: set nu”;</h3><ol><li>行号显示<code>:set nu</code></li><li>取消行号显示：<code>:set nonu</code></li></ol><h3 id="5-文件切换"><a href="#5-文件切换" class="headerlink" title="5.文件切换"></a>5.文件切换</h3><p>使用vim打开多个文件后，在末行模式下可以进行切换。</p><ol><li>查看当前已经打开的所有文件：<code>:files</code>(%a表示激活状态，#表示上一个打开的文件)</li><li>切换到指定文件：<code>:open 文件名</code></li><li>切换到上一个文(back previous)：<code>:bp</code></li><li>切换到下一个文件(back next)：<code>:bn</code></li></ol><h2 id="4-编辑模式"><a href="#4-编辑模式" class="headerlink" title="4.编辑模式"></a>4.编辑模式</h2><table><thead><tr><th>快捷键</th><th>功能描述</th></tr></thead><tbody><tr><td>i</td><td>在当前<strong>光标所在位置插入</strong>，光标后的文本相应向右移动</td></tr><tr><td>I</td><td>在<strong>光标所在行的行首插入</strong>，行首是该行的第一个非空白字符，相当于光标移动到行首执行 i 命令</td></tr><tr><td>o</td><td>在<strong>光标所在行的下插入</strong>新的一行。光标停在空行首，等待输入文本</td></tr><tr><td>O（大写）</td><td>在<strong>光标所在行的上插入</strong>新的一行。光标停在空行的行首，等待输入文本</td></tr><tr><td>a</td><td>在当前<strong>光标所在位置之后插入</strong></td></tr><tr><td>A</td><td>在<strong>光标所在行的行尾插入</strong>，相当于光标移动到行尾再执行 a 命令</td></tr><tr><td>esc键</td><td>退出编辑模式</td></tr></tbody></table><h2 id="5-扩展"><a href="#5-扩展" class="headerlink" title="5.扩展"></a>5.扩展</h2><p>1.代码颜色显示：“：syntax on&#x2F;off”</p><p>2.<strong>vim内置计算器</strong>：<br>a.进入编辑模式<br>b.按<code>“ctrl+r</code>，光标变成引号，，输入<code>=</code>，光标转到最后一行<br>c.输入需要计算的内容，按下enter后，计算结果回替代上一步中的引号，光标恢复</p><p>3.<strong>vim的配置</strong><br>a.文件打开时，末行模式下输入的配置为临时配置，关闭文件后配置无效<br>b.修改个人配置文件，可以永久保存个人配置（~&#x2F;.vimrc，如果没有可以自行创建）<br>c.修改全局配置文件，对每个用户生效（vim自带，&#x2F;etc&#x2F;vimrc）</p><p>注：个人配置文件优先级更高，当个人配置和全局配置发生冲突时，系统以当前用户的个人配置文件为准</p><p>4.<strong>异常退出</strong></p><p>在编辑文件后，未正常保存退出时，会产生异常退出交换文件（.原文件名.swp）<br>将交换文件删除后，再次打开文件时，无提示：“#rm -f .原文件名.swp”</p><p>5.<strong>别名机制</strong>：自定义指令<br>Linux中，存在一个别名映射文件： ~&#x2F;.bashrc<br>修改文件内容，可以自定义指令，重新登录账号后生效</p><p>6.<strong>文件快捷方式</strong><br>对于深层文件，可以创建文件快捷方式，便于后续操作：#ln -s 源路径 新路径</p><p>7.<strong>退出方式</strong><br>（1）在vim中退出文件编辑模式，可以使用<code>:q</code>或者<code>:wq</code><br>（2）建议使用<code>:x</code>：使用效果等同于<code>wq</code>，如果文件有改动则先保存后退出；但是如果文件没有做修改，会直接退出，不会修改文件更新时间，避免用户混淆文件的修改时间</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer </tag>
            
            <tag> program </tag>
            
            <tag> software </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Composition and classification of computers</title>
      <link href="/blog/2023/08/15/Composition-and-classification-of-computers/"/>
      <url>/blog/2023/08/15/Composition-and-classification-of-computers/</url>
      
        <content type="html"><![CDATA[<h2 id="一、计算机的组成和分类"><a href="#一、计算机的组成和分类" class="headerlink" title="一、计算机的组成和分类"></a>一、计算机的组成和分类</h2><h4 id="计算机的分类-（Wiki百科）"><a href="#计算机的分类-（Wiki百科）" class="headerlink" title="计算机的分类 （Wiki百科）"></a>计算机的分类 （Wiki百科）</h4><p><img src="../Composition-and-classification-of-computers/%E8%AE%A1%E7%AE%97%E6%9C%BA%E5%88%86%E7%B1%BB.png" alt="计算机分类"></p><h4 id="了解一下台式计算机的构成"><a href="#了解一下台式计算机的构成" class="headerlink" title="了解一下台式计算机的构成"></a>了解一下台式计算机的构成</h4><p>机箱、主板、中央处理器（CPU）、主内存、电源供应器（电源）、显卡、显示器、键盘、鼠标、外部存储媒体（硬盘）等</p><p>知道了上述构成，我们接下来就是逐一讲解。</p><h2 id="二、机箱的用途"><a href="#二、机箱的用途" class="headerlink" title="二、机箱的用途"></a>二、机箱的用途</h2><h4 id="概述"><a href="#概述" class="headerlink" title="概述"></a>概述</h4><p><img src="../Composition-and-classification-of-computers/%E6%9C%BA%E7%AE%B1%E6%A6%82%E8%BF%B0.png" alt="机箱概述"></p><h4 id="总结（选购机箱需要考虑的点）"><a href="#总结（选购机箱需要考虑的点）" class="headerlink" title="总结（选购机箱需要考虑的点）"></a>总结（选购机箱需要考虑的点）</h4><p>散热性能、外观偏好、体积大小</p><h2 id="三、主板的用途"><a href="#三、主板的用途" class="headerlink" title="三、主板的用途"></a>三、主板的用途</h2><p>关于主板废话不多说，看图。</p><p><img src="../Composition-and-classification-of-computers/%E4%B8%BB%E6%9D%BF.png" alt="主板"></p><p>注：主板的大小决定了机箱的大小</p><p>我们应该如何去挑选主板？</p><p>查看主板的一个规格和包装，<strong>关于主板主要是看提供的接口。</strong></p><p><img src="../Composition-and-classification-of-computers/%E4%B8%BB%E6%9D%BF%E8%A7%84%E6%A0%BC.png" alt="主板规格"></p><p><strong>因为同一个型号的主板产品，会因为接口的不同价格上会差很多</strong></p><h2 id="四、CPU处理器的用途"><a href="#四、CPU处理器的用途" class="headerlink" title="四、CPU处理器的用途"></a>四、CPU处理器的用途</h2><p>如图就是CPU</p><p><img src="../Composition-and-classification-of-computers/CPU.png" alt="CPU"></p><p>如何判断一个CPU的性能</p><p><strong>简单粗暴：贵的一定是好的。</strong></p><p>个人主机当中CPU的两大厂商</p><p>1.AMD ：更新周期快，短时间内会更新性能，更新周期&lt; 12 个月（ <strong>AMD YES</strong> ）<br>2.Intel（英特尔）：挤牙膏，更新周期为 18个月（ <strong>牙膏厂</strong>）</p><h3 id="4-1、Intel代表的处理器型号"><a href="#4-1、Intel代表的处理器型号" class="headerlink" title="4.1、Intel代表的处理器型号"></a>4.1、Intel代表的处理器型号</h3><p>1.奔腾（Pentium）：同样属于比较低端的产品，主要是用于Word文档办公。<br>2.赛扬（Celeron）：比较低端的产品，主要是上网使用。<br>3.酷睿（Core）：相比前两者，性能要求会高一点。</p><p><strong>注：重点学习酷睿Core</strong></p><h4 id="酷睿Core"><a href="#酷睿Core" class="headerlink" title="酷睿Core"></a>酷睿Core</h4><p>关于酷睿，同样的分为四个等级，i3、i5、i7、i9这四个，<strong>在同年代的产品当中性能遵循 i3&lt; i5 &lt; i7 &lt; i9</strong></p><p>​i3 : 文档、客户等处理要求快速，办公不卡（能流畅打CF、LOL等）<br>​i5 ：处理简单的视频，处理简单的程序，主流游戏<br>​i7 ：发烧，大型游戏，大型工程，专业用户，等等<br>​i9 ：强无敌</p><p>我们拿到一个CPU型号，如何判断他的性能呢 ?</p><p>如：<strong>英特尔（Intel）12代 i5-12400F CPU处理器 6核12线程 单核睿频至高4.4Ghz 10400F迭代升级款</strong></p><p>i5-12400F ：表示的是英特尔 酷睿core i5等级，12是代号，表示的是第12代的意思，体现CPU的一个发布时间，接下来的4就是性能代号，这个数字范围在0~9当中，这个数字越大性能越强。末尾的字母代表消费人群也是产品线后缀如：G、Y主打续航，U稍微有点续航，也稍微含点性能、F表示没有核显、H是焊接不可拆卸、K就是支持超频的，更好的性能、X是至尊，强无敌。</p><p>​注：如需比较I5 12600 vs i7 7700 ，这种等级和代号都不一致比较的话，则需要去网上搜索了。</p><h3 id="4-2、AMD代表的处理器型号"><a href="#4-2、AMD代表的处理器型号" class="headerlink" title="4.2、AMD代表的处理器型号"></a>4.2、AMD代表的处理器型号</h3><p>锐龙（ryzen）：其就类似英特尔的酷睿系列</p><p>速龙（athlon）：比较低端的产品，类似奔腾、赛扬</p><p>线程撕裂者（Threadripper）：强无敌</p><h4 id="锐龙Ryzen"><a href="#锐龙Ryzen" class="headerlink" title="锐龙Ryzen"></a>锐龙Ryzen</h4><p>​Ryzen3（r3）: 对标英特尔 i3<br>​Ryzen5（r5）：对标英特尔 i5<br>​Ryzen7（r7）: 对标英特尔 i7<br>​Ryzen7（r9）: 对标英特尔 i9</p><h4 id="关于AMD的型号的相关解释"><a href="#关于AMD的型号的相关解释" class="headerlink" title="关于AMD的型号的相关解释"></a>关于AMD的型号的相关解释</h4><p><img src="../Composition-and-classification-of-computers/AMD.png" alt="AMD"></p><p>如：<strong>AMD 锐龙5 5600G处理器(r5)7nm 搭载Radeon Graphic 6核12线程 3.9GHz 65W AM4接口</strong></p><p>第一部分是锐龙5（r5），就是类似于I5 ，接下来就是3 表示3000系列、还有5000系列等，类似于intle的代数，在接下来的6就表示性能，剩余部分与英特尔几乎一致。</p><h3 id="4-3、CPU核心、线程、缓存"><a href="#4-3、CPU核心、线程、缓存" class="headerlink" title="4.3、CPU核心、线程、缓存"></a>4.3、CPU核心、线程、缓存</h3><h4 id="什么是核心和线程"><a href="#什么是核心和线程" class="headerlink" title="什么是核心和线程 ?"></a>什么是核心和线程 ?</h4><p>我们通过一个例子：八核十六线程来解释说明：</p><p>核：八核是指CPU的核心有八个，核心（Core）又称为内核，是CPU最重要的组成部分。</p><p>线程：CPU调度的最小单位，同一时间执行的最小任务单位，线程的执行需要CPU的调度。</p><h4 id="线程和核心的关系："><a href="#线程和核心的关系：" class="headerlink" title="线程和核心的关系："></a>线程和核心的关系：</h4><p>八核十六线程是指使用了<strong>超线程技术</strong>，把一个物理核心，模拟成两个逻辑核心，理论上要像十六颗物理核心一样在同一时间执行十六个线程，而并非是我们理解的八核只能并发执行8线程，这里的八核指的是物理核心，而线程调度需要的是逻辑核心。</p><h4 id="主频、睿频"><a href="#主频、睿频" class="headerlink" title="主频、睿频"></a>主频、睿频</h4><p>​主频：CPU一个核心的基本运算能力。<br>​睿频：指当启动一个运行程序后，处理器会自动加速到合适的频率，而原来的运行速度会提升 10%~20% 以保证程序流畅运行的一种技术。就是工作起来后能在主频的运算能力上提高一些。</p><h4 id="三级缓存"><a href="#三级缓存" class="headerlink" title="三级缓存"></a>三级缓存</h4><p>缓存嘛，当然是越高越好了呀，可以类比Redis哈哈哈哈 。</p><h3 id="4-4、查看电脑的CPU信息"><a href="#4-4、查看电脑的CPU信息" class="headerlink" title="4.4、查看电脑的CPU信息"></a>4.4、查看电脑的CPU信息</h3><p>这里以Win10操作系统为例</p><p>​方式一：右键开始菜单—设备管理器<br>​方式二：此电脑右键—属性<br>​方式三：下载CPU-Z</p><p><img src="../Composition-and-classification-of-computers/CPU-Z-one.png" alt="CPU-Z-one"></p><p>对上图做一些解释说明：</p><p>​TDP：功耗<br>​规格中 @2.20GHz 是主频<br>Win10通过ctrl + shift + ESC 唤醒任务管理器，可以得到下图</p><p><img src="../Composition-and-classification-of-computers/%E4%BB%BB%E5%8A%A1%E7%AE%A1%E7%90%86%E5%99%A8.png" alt="任务管理器"></p><p><strong>我们发现电脑的主频是2.20GHz ，当前处于睿频状态2.28GHz</strong></p><h2 id="五、内存和内存条的用途"><a href="#五、内存和内存条的用途" class="headerlink" title="五、内存和内存条的用途"></a>五、内存和内存条的用途</h2><p>内存就是我们计组中的RAM，内存越大，也就是同时运行应用的数量越多。</p><p>例：<strong>金士顿 (Kingston) FURY 16GB(8G×2)套装 DDR4 3200 台式机内存条</strong></p><p>DDR4：指的就是内存条的代号，其分为DDR2、DDR3、DDR4 、DDR5等</p><p>2000：指的是内存的频率，<strong>首先肯定的是越高越好，但同样对主板的要求越高，选购的时候判断一下主板是否支持</strong></p><p>DDR2、DDR3、DDR4 的区别：</p><p><img src="../Composition-and-classification-of-computers/DDR%E5%8C%BA%E5%88%AB.png" alt="DDR区别"></p><p>放呆槽靠右：DDR4</p><p>放呆槽靠左：DDR3</p><p>放呆槽中间：DDR1，DDR2</p><h3 id="5-1、如何查看自己电脑的内存和主板信息"><a href="#5-1、如何查看自己电脑的内存和主板信息" class="headerlink" title="5.1、如何查看自己电脑的内存和主板信息"></a>5.1、如何查看自己电脑的内存和主板信息</h3><p>关于内存和主板的信息，同样可以使用CPU-Z进行查询</p><h4 id="查看主板信息"><a href="#查看主板信息" class="headerlink" title="查看主板信息"></a>查看主板信息</h4><p><img src="../Composition-and-classification-of-computers/CPU-Z-TWO.png" alt="CPU-Z-TWO"></p><h4 id="查看内存信息"><a href="#查看内存信息" class="headerlink" title="查看内存信息"></a>查看内存信息</h4><p><img src="../Composition-and-classification-of-computers/CPU-Z-three.png" alt="CPU-Z-three"></p><p><strong>内存频率乘以2的结果是就是我们的购买内存条需要购买的频率</strong></p><h2 id="六、电源的用途"><a href="#六、电源的用途" class="headerlink" title="六、电源的用途"></a>六、电源的用途</h2><p>什么是电源？</p><p><img src="../Composition-and-classification-of-computers/%E7%94%B5%E6%BA%90.png" alt="电源"></p><p>​笔记本的电源就可以看作充电器，哈哈哈！</p><h4 id="台式机的电源（重点）"><a href="#台式机的电源（重点）" class="headerlink" title="台式机的电源（重点）"></a>台式机的电源（重点）</h4><p>电源的选择要根据自己的显卡和CPU等其他配置的功率去判断。<strong>用以避免供电不足的问题</strong></p><p><img src="../Composition-and-classification-of-computers/%E6%90%9C%E7%B4%A2.png" alt="搜索"></p><p>实在不行可以直接这么搜索，hhhhh。 <strong>关于电源的选择需要具体的问题具体分析</strong></p><h2 id="七、硬盘的用途"><a href="#七、硬盘的用途" class="headerlink" title="七、硬盘的用途"></a>七、硬盘的用途</h2><p>硬盘也就是我们计组当中的ROM，存储内存</p><p><img src="../Composition-and-classification-of-computers/%E7%A1%AC%E7%9B%98.png" alt="硬盘"></p><p>上面这一大串，就是官话，人话就是：<strong>硬盘分两类：机械硬盘、固态硬盘</strong>，长得就是上图 的样子</p><h3 id="7-1、机械硬盘"><a href="#7-1、机械硬盘" class="headerlink" title="7.1、机械硬盘"></a>7.1、机械硬盘</h3><h4 id="对机械硬盘做一些介绍"><a href="#对机械硬盘做一些介绍" class="headerlink" title="对机械硬盘做一些介绍"></a>对机械硬盘做一些介绍</h4><p>例： <strong>希捷(Seagate)4TB 256MB 5400RPM 台式机机械硬盘 SATA接口 希捷酷鱼BarraCuda系列(ST4000DM004)</strong></p><p>解释：4TB就是容量、256M就是硬盘的缓存（同样是越大越好）、5400RPM就是转速（越大越好），SATA接口如图所示</p><p><img src="../Composition-and-classification-of-computers/%E6%9C%BA%E6%A2%B0%E7%A1%AC%E7%9B%98.png" alt="机械硬盘"></p><h3 id="7-2、固态硬盘（推荐）"><a href="#7-2、固态硬盘（推荐）" class="headerlink" title="7.2、固态硬盘（推荐）"></a>7.2、固态硬盘（推荐）</h3><h4 id="对固态硬盘（SSD）做一些介绍"><a href="#对固态硬盘（SSD）做一些介绍" class="headerlink" title="对固态硬盘（SSD）做一些介绍"></a>对固态硬盘（SSD）做一些介绍</h4><p>固态硬盘会提供如下的接口</p><p>​SATA接口 : 提供SATA接口的目的是为了让只有SATA接口的老电脑也能更换固态的一个普适性。<br>​MiniSATA接口 : 为以前的笔记本提供的接口，基本已经停产。<br>​PCI-E接口：原本是为显卡提供的接口，但是之前为了速度存在这种固态，基本已经停产，速度已达到&lt;&#x3D; 6000MB&#x2F;s。<br>​U.2接口：基本上停产。<br>​M.2接口（主流）：支持NVME协议，速度已达到&lt;&#x3D; 7000MB&#x2F;s，如图所示</p><p><img src="../Composition-and-classification-of-computers/%E6%8F%92%E6%A7%BD.png" alt="插槽"></p><p>解释一下如图：1 x M.2 2242-22110(PCle 4.0 x4 from CPU) 这句话</p><p>​主板上的一个M2接口支持pcie x4通道（通道就是连接CPU 走的路），因此这个M2接口支持满足NVME协议PCle 4.0的固态。<br>​主板上的PCIE插槽支持pcie通道，因此可以链接显卡</p><h3 id="7-3-、区别"><a href="#7-3-、区别" class="headerlink" title="7.3 、区别"></a>7.3 、区别</h3><h4 id="固态硬盘和机械硬盘的区别"><a href="#固态硬盘和机械硬盘的区别" class="headerlink" title="固态硬盘和机械硬盘的区别"></a>固态硬盘和机械硬盘的区别</h4><table><thead><tr><th align="center">机械硬盘</th><th align="center">固态硬盘</th></tr></thead><tbody><tr><td align="center">读写速度 &lt;&#x3D; 100MB&#x2F;s</td><td align="center">需要根据接口判断速度SATA一般是&lt;&#x3D; 550MB&#x2F;s</td></tr><tr><td align="center">寿命低</td><td align="center">寿命长</td></tr><tr><td align="center">价格低</td><td align="center">价格较高</td></tr></tbody></table><h2 id="八、显卡的用途"><a href="#八、显卡的用途" class="headerlink" title="八、显卡的用途"></a>八、显卡的用途</h2><p> 如果说CPU是电脑的大脑，那么显卡就是展示画面的一个画家。CPU首先要把需要显示的内容设计出来，然后再通过显卡一张一张图片显示出来。一张一张的图片就是大家经常所说的帧数。想要让这些图片具有连贯作用，就需要显卡发挥更好的作用。性能一般的显卡在连贯图片的时候可能会比较卡顿，整体感觉不是特别流畅。</p><h4 id="显卡当中的两大厂商"><a href="#显卡当中的两大厂商" class="headerlink" title="显卡当中的两大厂商"></a>显卡当中的两大厂商</h4><p>​NVIDIA（英伟达）：生产的显卡称为N卡（同级别，游戏方面优化稍好一些）<br>​AMD ：生产的显卡称为A卡（同级别，图形渲染和画面效果稍好一些）</p><h3 id="8-1、NVIDIA（英伟达）的显卡"><a href="#8-1、NVIDIA（英伟达）的显卡" class="headerlink" title="8.1、NVIDIA（英伟达）的显卡"></a>8.1、NVIDIA（英伟达）的显卡</h3><h4 id="相关产品代号"><a href="#相关产品代号" class="headerlink" title="相关产品代号"></a>相关产品代号</h4><p>​GeForce 900：例如 GTX960、GTX960TI、GTX980</p><p>​GeForce10：例如 GTX1050、GTX1060、1050TI、1080TI</p><p>​GeForce16：例如GTX1650、GTX1660</p><p>​GeForce RTX 20系列：RTX2060、RTX2070、RTX2070 Super、RTX2080 Super、RTX2080TI</p><p>​GeForce RTX 30系列：RTX3060、RTX3050TI、RTX3090TI</p><p>​…</p><h4 id="GTX-和-RTX-的区别渲染图"><a href="#GTX-和-RTX-的区别渲染图" class="headerlink" title="GTX 和 RTX 的区别渲染图"></a>GTX 和 RTX 的区别渲染图</h4><p><img src="../Composition-and-classification-of-computers/%E5%8C%BA%E5%88%AB%E6%B8%B2%E6%9F%93.png" alt="区别渲染"></p><p>分析显卡的一个参数</p><p><strong>七彩虹（Colorful）火神iGame GeForce RTX 3090 Vulcan OC 24G 1695-1785Mhz 赛博朋克2077游戏光追电脑显卡</strong></p><p>RTX3090 上面已经说过了，24G表示的是显存（同样是越大越好）。</p><h3 id="8-1、AMD的显卡"><a href="#8-1、AMD的显卡" class="headerlink" title="8.1、AMD的显卡"></a>8.1、AMD的显卡</h3><h4 id="A卡的产品系列代号（只介绍当前还可正常使用的）"><a href="#A卡的产品系列代号（只介绍当前还可正常使用的）" class="headerlink" title="A卡的产品系列代号（只介绍当前还可正常使用的）"></a>A卡的产品系列代号（只介绍当前还可正常使用的）</h4><p>​R200系列：例如 R9 295 X2（旗舰）、R9 290X、R9 280、R7 265<br>​R300系列：例如 R9 390、R9 380X、R7 360<br>​RX 400系列：例如 RX 460、RX 470、RX 480<br>​RX 500系列：例如 RX 550、RX 560、RX 570、RX 580、RX 590<br>​RX Vega系列：例如 RX Vega 56、RX Vega 64、RX Vega 64水冷<br>​RX 5000系列：例如 RX 5500 XT、RX 5600、RX 5600 XT、RX 5700、RX 5700 XT<br>​RX 6000系列：例如 RX 6400、RX 6500 XT、RX 6600、RX 6600 XT、RX 6700 XT、RX 6800、RX 6900 XT</p><h4 id="A卡的产品系列代号讲解"><a href="#A卡的产品系列代号讲解" class="headerlink" title="A卡的产品系列代号讲解"></a>A卡的产品系列代号讲解</h4><p>1.先看前缀，这几年AMD的前缀都是RX开头，如RX580、RX5700等，<br>2.前缀后面一第一个数字和英伟达一样表示第几代, RX580就表示第5代，这个数字越大越好。值得一提的是在RX400系与RX500系之后并不是600系，而是RX Vega系列，比如RXVega56和RX Vega64，这是为了阻击英伟达GTX1080临时起的系列。还有一个50周年纪念版RX5700、RX5700XT，其对标的是英伟达的RTX2060&#x2F;2070。再往上还有顶级的Radeon VIl。<br>3.代数后面的数字表示性能等级，RX580性能高于RX570，RX570性能高于RX550，这个数据也是越大越好。<br>4.最后看后缀，<strong>X2表示双芯片</strong>，这个是AMD同代产品里面最好的，比如R9 295 X2,虽然是上一代的旗舰但性能比RX590还要强。<strong>X表示完整核心</strong>，GE BOOST，XT PRO表示加强版，<strong>D表示核心阉割</strong>。</p><h4 id="总结"><a href="#总结" class="headerlink" title="总结"></a>总结</h4><p>A卡的优势在于性能比更高，在同价位上性能是强于N卡的，比如同级别的GTX1660和RX590，两者性能旗鼓相当，但是RX590价格要便宜200多。<br>缺点就是功耗略高，用户没有N卡多，对游戏厂商关系没有N卡友好，驱动也没有N卡稳定。我推荐大家在选购中端和入门机型的时候A卡N卡都可以用，区别不大的，但是高端机型的话还是选英伟达吧，没办法，谁让英伟达和游戏厂商关系好还有光追呢，当然了你得不差钱。</p><h2 id="完结"><a href="#完结" class="headerlink" title="完结"></a>完结</h2><h4 id="一些要说的话"><a href="#一些要说的话" class="headerlink" title="一些要说的话"></a>一些要说的话</h4><p>到这里，对于机箱、主板、CPU、内存、硬盘、电源、显卡的学习就结束了，注意这篇文章并不是教你哪些百度上的哪些一连串的知识，而是让你看完能够切实的知道什么样的硬件是好的，型号怎么看，怎么选，最后自己再去补充一些知识达到能够自己选配件配置电脑的能力。</p>]]></content>
      
      
      <categories>
          
          <category> Computer </category>
          
      </categories>
      
      
        <tags>
            
            <tag> computer </tag>
            
            <tag> technology </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Love Brain of Technical Man: Application Strategies</title>
      <link href="/blog/2023/08/15/The-Love-Brain-of-Technical-Man-Application-Strategies/"/>
      <url>/blog/2023/08/15/The-Love-Brain-of-Technical-Man-Application-Strategies/</url>
      
        <content type="html"><![CDATA[<p>在现代社会，技术人扮演着越来越重要的角色。然而，对他们的一般印象往往局限于专业领域，这就是为什么TA们恋爱机会少的一个重要原因。认识到这些还不够，往常情况，他们会说自己不具备社交和结识异性的能力，甚至于认为自己的理性与逻辑是无法讨得异性喜爱的。这一错误观点我们在此打破，技术人经常被视为冷静、逻辑和分析型的，但这些特点如何转化为恋爱中的优势是一直被忽视的话题。</p><p>（1）逻辑性强</p><p>案例 - 李明与小芳：</p><p>李明，一名擅长数据处理和算法分析的软件工程师，与小芳，一位热爱表现艺术并专注于情感表达的艺术专业学者，两人有着截然不同的专业背景。然而，当他们面临决定是否搬到一起居住时，由于他们的职业背景、价值观和生活方式的差异，两人产生了分歧。我想这一点很多情侣都会遇到，而且是无法避免的问题。</p><p>李明利用了他所学的决策树和SWOT分析技术，来评估和分析搬到一起居住的决策（听起来很夸张是吧）。他列出了共同生活的各种可能性、风险和收益，然后与小芳共同讨论。经过一系列的逻辑分析，小芳开始认识到李明所提供的解决方案是在为双方的未来考虑。她感受到了强烈的安全感，而李明也逐渐学会了尊重和理解小芳的情感需求。这一基于逻辑的决策方式确保了双方的需求都得到了充分的考虑，促进了他们之间的和谐与互信。我们来看一下他们一些常见问题的经过：</p><p>  •   房屋地理位置：</p><p>小芳倾向于住在市中心，她的艺术工作室、展览馆和艺术家交流中心都在那里。对她来说，市中心不仅仅是一个工作的地方，更是她灵感的来源。每次走在繁华的街道上，观察行人的表情和建筑的轮廓，都能给她带来无尽的创作灵感。</p><p>而李明的需求则截然不同。他在一家位于市郊的技术公司工作，那里的工作节奏快、竞争激烈。每天，他都需要高度集中精力，确保代码的效率和质量。对他来说，减少通勤时间意味着更多的休息和工作时间。</p><p>面对这一矛盾，李明决定采用更为系统和专业的方式来分析这个问题。他选择了地理信息系统 (GIS) 和多准则决策分析 (MCDA) 这两种工具。</p><p>A.地理信息系统 (GIS)：李明首先收集了市中心到他工作地点的所有可能的交通路线数据，包括公交、地铁和自驾的时间成本。他还考虑了小芳常去的艺术场所，标注了她每周的行程。</p><p>B.多准则决策分析 (MCDA)：考虑到住房选择不仅仅是通勤问题，李明列出了其他重要的决策标准，如租金、生活成本、周边环境、安全性等。他为每个标准赋予了权重，并将这些数据输入MCDA模型。</p><p>最终的分析结果显示，一个位于市中心与市郊中间地带的社区最能满足他们双方的需求。这个地点不仅有便捷的交通网络，还拥有小芳喜欢的艺术氛围，并且租金和生活成本在双方的预算范围内。李明详细地向小芳展示了他的分析过程和结论。面对如此深入且专业的分析，小芳不禁为李明的逻辑性和为他们的未来生活所付出的努力而感动。经过讨论，他们共同决定选择这个社区作为他们的新家，虽然一般人也可以收集信息，但无法做得如此专业与效率，很有可能还没下决定时候你对象就要跟你分手了，大多数人因为信息不足外，还没有好的决定。</p><p>  •   居住费用：</p><p>对于李明来说，作为一名初入职场的软件工程师，他非常重视资金的合理使用。他倾向于选择经济型住宅，认为这样可以为未来的不确定性留下更多的安全余地。另一方面，小芳，作为一个充满激情的艺术家，对于生活环境有着特别的要求。她觉得高档住宅或具有文艺氛围的地方更能激发她的创作灵感，同时也能更好地展现她的生活态度。</p><p>为了对这个问题进行全面的考虑，李明决定进行SWOT分析，以期系统地评估两种住房类型的优势、劣势、机会和威胁。</p><p>A.经济型住宅：</p><p>优势：费用低廉，有更多的资金流动性；</p><p>劣势：可能的生活设施简单，社区环境可能并不理想；</p><p>机会：节省的资金可以用于投资或支持其他重要的生活项目；</p><p>威胁：随着时间的推移，可能会对升级生活环境产生强烈的需求。</p><p>B.高档住宅：</p><p>优势：更好的生活质量，环境和设施更加完善，可能更加接近市中心和小芳的工作场所；</p><p>劣势：费用较高，可能导致财务压力增大；</p><p>机会：在优越的环境中生活和工作，有助于提高工作和创作的效率；</p><p>威胁：如果遭遇经济下滑，高额的住房开销可能成为负担。</p><p>在深入分析后，李明向小芳提出了一个妥协的建议：选择一个经济型住宅，但在一个具有浓厚艺术氛围的社区。这样，他们不仅可以节省资金，还可以确保小芳得到艺术创作的灵感。更重要的是，李明提议用节省下来的资金为小芳的艺术项目提供资金支持。小芳深受感动，她看到了李明对她事业的支持，同时也意识到为共同的未来做出妥协的重要性。经过充分的讨论，两人最终决定选择李明提出的方案。他们二人在中间的配合与协商过程才是重中之重，他们没有吵架，也没有为了各自的利益而产生纠纷，更没有把这件事情当做烦恼！记得，你和伴侣之间的问题一定可以得到解决，你一定不能在你的伴侣面前愁眉苦脸！你要做出分析行动的同时，还要及时的鼓励你的伴侣，你要让对方相信你们可以一起度过难关！</p><p>  •   家居装修风格：</p><p>面对家居装修风格的选择，小芳和李明的审美观念产生了冲突。小芳，作为一个热爱艺术的人，总是想在生活的每一个角落都能感受到艺术的踪迹。她喜欢那些充满艺术感的设计，如手绘壁画、特色吊灯、甚至是异国情调的家具。而李明则是一个典型的实用主义者，他更看重家居的功能性、耐用性和维护成本。</p><p>为了更科学地评估各种装修风格的可行性，李明决定进行风险分析：</p><p>A. 艺术风格：</p><p>优势：提供了良好的视觉体验，能够激发住户的创意思维；</p><p>劣势：可能涉及高成本、高维护的材料或设计；</p><p>风险：特殊材料可能不够耐用，需要定期维护；手工艺品可能需要定期清理或更换。</p><p>B.实用风格：</p><p>优势：注重功能性、耐用性，通常采用低维护、长寿命的材料；</p><p>劣势：可能缺乏某些审美元素，使得空间显得过于单调；</p><p>风险：过于注重实用性可能忽略住户的情感需求和审美体验。</p><p>经过分析，李明向小芳解释了他的担忧。他提出，一些充满艺术感的设计元素可能不够耐用，或者需要定期维护，这可能会带来额外的成本和麻烦。然而，他也承认空间中的艺术元素能够提供一种独特的审美体验，这是实用风格所不能替代的。经过深入的沟通，两人决定在装修风格上进行妥协。客厅，作为接待客人的主要区域，将采用小芳喜欢的艺术风格，以展现其个性和审美。而卧室、厨房和卫生间等功能性强的区域，则会选择李明倾向的实用风格，确保耐用性和低维护成本。李明还喜欢干净和科技的卫生间，所以他们彼此为对方着想；李明陪小芳走遍艺术大街，购买一些装饰品，并且尊重和帮忙装修客厅；在此期间，小芳还专门去家居店买了一些卫生间的高档用具，高科技满满的浴缸、花洒、镜子，甚至装修都是高科技感的……这种妥协不仅满足了双方的需求，还为他们的家创造了一个既实用又富有艺术气息的完美空间。</p><p>恋爱中的决策经常需要双方进行权衡和考虑。在这一过程中，逻辑性的思考方式有时可能会比情感更能帮助双方看清事情的实质，我们可以看出李明每次都是做出了两个人的看法，写在纸上并且罗列种种事实。记得，只有罗列事实才能够分析。Bartels和Urminsky在2011年的论文《On Intertemporal Selfishness: How the Perceived Instability of Identity Underlies Impatient Consumption》（Bartels, D. M., &amp; Urminsky, O. (2011). On Intertemporal Selfishness: How the Perceived Instability of Identity Underlies Impatient Consumption. Journal of Consumer Research, 38(1), 182-198.）中所提，人们在面临决策时，逻辑和长期的思维方式往往能导致更加明智和受益的选择。逻辑性强的人在面对恋爱中的问题时，更可能利用科学方法，如概率论、风险分析和博弈论来进行决策。这一逻辑性的决策方式，能够确保双方的需求和期望都被充分考虑，从而促进恋爱关系的和谐与稳定，而这一点正是普通人无法做到的，到了这一步甚至很多情侣就此分道扬镳，为了点小事吵架而不和，这种事情时有发生在我们身边，希望大家引以为戒，多多学习李明的做法。（此做法不分性别）</p><p>（2）对细节的敏感度与恋爱关系的深化</p><p>废话不多说，直接看案例。</p><p>张涛，一个资深的网络安全专家，有着对事物细微变化的出奇的敏感度。这种能力不仅在他的工作中大放异彩，也在他的恋爱生活中起到了关键的作用。</p><p>玲玲是一个充满活力的市场营销人员，她的生活节奏快，常常为工作疲于奔命。某天，由于项目的压力，玲玲情绪明显低落。对于大多数人来说，玲玲的变化可能并不明显，但对于张涛来说，这些细微的变化都逃不过他的眼睛。</p><p>他首先观察到玲玲的非言语行为，发现她的面部表情略显僵硬，嘴角下垂，这是一种典型的情感低落的表征。再者，他发现玲玲的眼神失去了往常的光泽，瞳孔略微扩大，可能是皮质醇——一种与压力相关的激素——的作用。她的语速变得稍快，语调也显得尖锐，都是情绪波动的迹象。当然，更明显的信号是，玲玲换了一个新发型——这可能是她想要通过外部变化来调节内心情感的努力。</p><p>为了准确地判断玲玲的情绪状态，张涛尝试与她进行深入的交流，利用开放式问题：“你今天看起来有些不同，工作上是不是有什么让你感到不开心的事情？”玲玲最初的回应是逃避和抵抗，她试图转移话题，表示“没什么大不了的。”</p><p>但张涛并没有轻易地放弃。他深知，要真正了解一个人的内心，比破解一道复杂的算法还要难，更需要时间和耐心（这一点是很多技术人员也做不到的，我必须承认很多人对异性是没有耐心的，不论男生还是女生都有可能发生丢失耐心的表现）。张涛面对玲玲的初步回避，他决定采取一个更加细致、策略性的方法。</p><p>张涛知道，食物有时能够温暖人的心。因此，他决定为玲玲准备一道特制的晚餐。他精选了玲玲最喜欢的食材，甚至提前几天去市场为她挑选那些新鲜的蔬菜和鱼。厨房里，香气袭人，张涛刻意为她烹制了那些她提到过、记忆中的拿手好菜。</p><p>晚饭时，张涛为玲玲铺好餐巾，准备了她最喜欢的果汁。他主动夹给玲玲她最爱的菜，并不断询问：“玲玲，还想吃点什么吗？”或者“这个味道如何？”他关心的每一句话，都希望能够为玲玲带来一点点的温暖。</p><p>但玲玲的心情显然并未因为这顿丰盛的晚餐而有所改观。尽管她微微地笑了，尝了尝那些菜，但她的眼神还是显得有些失落。张涛可以感受到，她虽然感激他为她所做的一切，但内心的困惑和压力并没有因此得到解决。她轻轻地推开了自己的餐盘，低头不语。</p><p>这时，张涛意识到，仅仅通过食物是无法解决玲玲心中的问题的，他也并没有急于追问或逼迫玲玲，而是选择了一个适当的时机，晚饭半小时后，当两人坐在沙发上，点上一盏温馨的台灯，播放了玲玲喜欢的轻音乐。这些都是为了创造一个轻松、安心的环境，让玲玲感觉被关心和尊重。他轻声地开始：“玲玲，我注意到你最近似乎有点不一样。或许我不能完全理解你现在的感受，但我真的希望能在你需要的时候陪在你身边。”玲玲的眼眸中闪过一丝波动，但她仍然尝试避免这个话题。</p><p>张涛深吸了一口气，他回想起了自己在工作中遇到的一个特别棘手的项目。那次，他的团队负责一个大型的网络安全升级，而在项目进行到一半时，他们发现了一个严重的漏洞，这意味着大量的代码需要被重写。由于这个突如其来的问题，整个项目的时间表被打乱，而且还面临着巨大的经济损失。张涛作为团队负责人，承受了巨大的压力，他知道整个团队的人都在看着他，等待他给出解决方案。</p><p>“那段时间，”张涛缓缓地说，“我每天都在办公室里熬夜，几乎没有休息。我也知道，我不能让团队的其他成员因为我的决策而受到太大的压力。但每当我想到可能会失败，可能会让公司和同事们失望，我心里就感到特别沉重。”</p><p>他又接着说：“有一天，我在办公室里，看着窗外的夜景，突然意识到，我不能再这样下去。我决定与团队成员召开紧急会议，集思广益，寻找解决方案。经过长时间的讨论和合作，我们最终找到了一个可行的解决方案，并成功地完成了项目。”</p><p>张涛望着玲玲的眼睛，那双昔日充满活力的眼眸此刻泛着微微的泪光。他轻轻握住她的手，语气充满了温柔与坚定：“玲玲，不论你经历什么，无论未来还有多少困难和低谷，我都会在你身边。我们一起面对，一起克服。”玲玲深深地看了张涛一眼，嘴角上扬，露出一个微笑，她轻轻靠在张涛的肩膀上：“张涛，你知道吗？这就是我为什么那么爱你，因为我知道，不论如何，你都爱我，都会在我身边。” 张涛微笑，轻轻地吻了玲玲的额头，低语道：“不论如何，我都会在，因为我爱你。”</p><p>经过这一系列的努力，玲玲的防备逐渐被打破，她终于流露出真实的情感与泪水，描述了自己的压抑和疲惫，他们两个人在床上躺着，彼此泛红萌生爱意。张涛倾听着，没有打断她，他们二人侧身对视，彼此傻笑，据说当天晚上还喜提二胎。这个也是我听说的，那故事的起源在一棵树下我们夏季的野炊——一对儿情侣真实经历的分享，写到此处，估计只有亲身经历过的人才能明白吧（我自己被自己写哭了）。</p><p>所以，结合以上作为本小节的总结：</p><p>在恋爱关系中，逻辑性强是一种十分有价值的品质。如李明与小芳的例子，逻辑思考帮助伴侣们更加清晰地评估和处理各种日常生活中的挑战。它能让情侣们看到彼此的需求、理解对方的立场，并寻找双赢的解决方案。这不仅促进了两人之间的合作，还加深了他们对彼此的信任和理解。</p><p>细节的敏感度是关心和爱的具体体现。如张涛与玲玲的故事中，张涛对玲玲的微小变化都能敏感地捕捉到，这种细微的关心为玲玲带来了巨大的安慰。能够观察到伴侣的不同和需要，能更精确地给予他们需要的关心和支持。</p><p>但同样，这种敏感度也需要与逻辑性结合，来找到真正解决问题的方法。纵然食物无法完全化解玲玲的困扰，但张涛在细节中所展现的关心，为接下来深入的对话铺垫了道路。</p><p>希望看了本小节的每一个伴侣都能像李明和张涛一样，既具备逻辑的头脑，又拥有对细节敏感的心。愿每一对情侣，在爱的旅途中，都能够通过对方的指引，找到最适合自己的道路，共同创造属于两人的甜美回忆。在任何情况下，都能真诚地对对方说：“不论如何，我都在。”、“不论如何，我都爱你。”</p>]]></content>
      
      
      <categories>
          
          <category> Love </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> love </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>How to maintain a healthy mindset as you pursue long-term goals</title>
      <link href="/blog/2023/08/12/How-to-maintain-a-healthy-mindset-as-you-pursue-long-term-goals/"/>
      <url>/blog/2023/08/12/How-to-maintain-a-healthy-mindset-as-you-pursue-long-term-goals/</url>
      
        <content type="html"><![CDATA[<p><strong>追求长期目标就像是跑马拉松。</strong>你可能会遇到各种障碍、疲惫和不确定性，但坚持下去的关键在于培养一种坚韧不拔和健康的心态。</p><h5 id="1-明确你的“为什么”-追寻目标背后的动机"><a href="#1-明确你的“为什么”-追寻目标背后的动机" class="headerlink" title="1. 明确你的“为什么”: 追寻目标背后的动机"></a>1. 明确你的“为什么”: 追寻目标背后的动机</h5><p>对于每一个目标背后，都有一个深层次的“为什么”。理解这个“为什么”并非只是简单的了解你要做什么，而是深入到为什么你要这么做。这是一个内心的驱动力，是在困境中为你点亮前行之路的明灯。</p><p>当我们遭遇挑战、困难或者疲惫时，回想起这个“为什么”经常可以为我们注入新的活力。它是你内心的声音，告诉你原来的决定并不是随意的，而是有意义的。了解自己为什么要设定这个目标是非常重要的。当你清楚自己的动机，你就更容易在困难时期找到动力。每当你感到挫败或者想要放弃时，回想起你的初衷，这会给你加油打气。如果这个目标是无法实现的，例如“我要一年里赚一千个亿”，诸如此类不仅仅不会让你接近目标，反而会把你直接扼杀在初始化的摇篮里，甚至于你说不出一年里赚一个亿的“为什么”。因此目标的过程不在于仅仅设立了去追逐，而是在于你能够解释清楚“为什么”，否则即便是圣人也难以坚持，因追求一个不知道是什么的东西，很显而易见任何人都会摆烂。目标的确立，就是对“为什么”的解释。</p><p>我来个案例解释吧。</p><p>小张是一个程序员，他每天工作十几个小时，代码、测试、再代码。某一天，他突然觉得很疲惫，不再像起初那样对编程充满激情。他开始质疑自己，为什么要这样每天对着电脑，为什么不选择一个轻松的工作？</p><p>这时，小张回想起了自己大学时期的梦想。当时的他，希望利用技术来为人们解决实际问题，希望自己的代码能够帮助到需要的人。他记得自己曾经说过：“我不仅仅是为了工资在编程，我是为了使世界变得更好。”</p><p>这个“为什么”为小张提供了方向。他意识到，自己不是为了工资或者社会地位在编程，而是为了实现内心的梦想。这个动机让他重新找回了激情，即使面对困难和压力，他也能继续前行，因为他知道自己为什么而战。</p><p>所以，无论你的目标是什么，都要时常提醒自己背后的“为什么”，这样你的目标都会随着你的过程而递进，当你明确了这个动机，你就能更坚韧、更有决心地追求你的梦想，无论路途多么崎岖，一个长期的目标很有可能会随着时间而改变，这一点很正常，但放弃目标不代表是你是一个懒惰、堕落、无能的人，而是代表着你有新的目标，它看起来更加诱人，不至于像我们之前说的“一年赚一千亿”那样天方夜谭。</p><h5 id="2-自我关怀：照顾好自己，确保持续前行"><a href="#2-自我关怀：照顾好自己，确保持续前行" class="headerlink" title="2.自我关怀：照顾好自己，确保持续前行"></a>2.自我关怀：照顾好自己，确保持续前行</h5><p>在追求长期目标的过程中，我们往往会专注于目标本身，忽略了为达到这个目标而努力的那个人——我们自己。但实际上，没有一个健康的身体和稳定的心态，任何目标都难以实现。因此，为了确保我们能够持续、有效地追求目标，自我关怀显得尤为重要。</p><p>我见过很多大学生，他们只坐一天，从来不考虑自己的生活问题。例如衣服是否洗好？鞋是否勤刷勤晒？被子是否也需要晒？……不要小瞧这些生活问题，因为他会给你的目标提供自我关怀。如果你连你自己的生活都无法处理好，那你还能处理什么呢？当然我知道你会很忙，但你至少应该静下来好好规划一下自己的时间，怎么利用好时间去合理地解决这些小事。当你生活上的问题都得到解决，并且生活很好的时候，你会把你的精力持续地投放在目标上，这是自然的，而不是一种强制的。特别注意这种自然的方式，卓有成效。</p><p>A.定期休息：工作和学习都需要集中注意力，但人的精力是有限的。每隔一段时间，给自己一个短暂的休息，这可以帮助你恢复精力，提高工作效率。</p><p>B.坚持锻炼：运动不仅可以保持身体健康，还能释放压力、提高情绪。无论是跑步、游泳、瑜伽还是简单的散步，都是很好的选择。</p><p>C.饮食均衡：身体是你的工具，你需要给它提供足够的营养。吃得健康，意味着你为身体提供了足够的能量和营养，来应对每天的挑战。</p><p>D.寻找释放压力的方法：每个人都有自己的放松方式，可能是阅读、冥想、旅行、听音乐或与家人、朋友聚会。找到对你有效的放松方法，并定期为自己“充电”。</p><p>  不要小瞧了这些，有些人每天都活在压力中，他们有一个很好的理由：我需要学习，我需要工作。殊不知ABCD都在的时候，你会达到最佳的状态。我知道这不容易，但你需要时间去做，而不是停止了。</p><p>案例分享：小李的自我关怀之路</p><p>小李是一名初创公司的创始人，她每天工作到深夜，经常忘记吃饭，甚至没有时间做运动。但很快，她发现自己的健康状况每况愈下，情绪也变得容易焦虑。她意识到，如果这样下去，她的公司可能会因为她的健康问题而受到影响。</p><p>于是，小李决定为自己制定一个自我关怀计划。她开始每天早上跑步，每周参加一次瑜伽课程，确保每天吃三餐，并为自己预留一些阅读和冥想的时间。不出所料，她的健康状况和情绪都得到了显著的改善，她也更有信心和能量去面对公司的挑战。</p><p>追求目标是一场马拉松，而不是短跑。要想走得更远，更持久，我们必须学会照顾好自己。只有当我们的身体和心灵都处于最佳状态，我们才能最大限度地发挥自己的潜能，迎接每一个挑战。</p>]]></content>
      
      
      <categories>
          
          <category> Life </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>The Love Brain of Technoman: Introduction</title>
      <link href="/blog/2023/08/11/The-Love-Brain-of-Technoman-Introduction/"/>
      <url>/blog/2023/08/11/The-Love-Brain-of-Technoman-Introduction/</url>
      
        <content type="html"><![CDATA[<p>程序员与常见的恋爱误区？在我们的日常生活中，有一些关于程序员和技术人员的固定观念或传言。例如，“程序员找不到对象”，“技术人员情商很低”，或者“他们不注重形象，因此不容易获得异性的吸引”。这些观点，在某种程度上可能会给这一群体带来一定的压力和困惑。</p><p>须知：任何群体都有多元化的个体。技术人员中既有内向的，也有外向的；有的人可能真的不太注重形象，但也有人非常讲究穿着打扮。因此，将整个技术群体归纳为某一种特定的标签是不公平的。正如很多技术人员他们喜欢下班后健身，他们在其他非技术领域社交圈也得到认可，人总不是单一的产物。我们还需要知道，技术人员有各种性别，而非单纯“他者”的特权。</p><p>为什么多数人会有这个误解？因为技术人员的工作通常需要长时间的沉浸在复杂的问题中，这可能导致他们在社交场合显得有些“不合群”。但这并不意味着他们不懂得如何与人沟通或缺乏情商。实际上，许多技术人员在解决与人相关的问题时，往往会用到他们解决技术问题的逻辑和策略，这便是我们本文必须强调的。</p><p>为什么要谈“技术人的恋爱脑”？在如今这个充斥着技术的时代，每个人都或多或少受到技术的影响。从我们工作的方式、消遣的方式，到我们社交的方式，技术都已经成为了我们生活中不可或缺的一部分。但是，当我们提及恋爱，很少有人会想到它与技术有什么联系。而实际上，对于很多深陷技术领域的人来说，他们的恋爱方式、恋爱思考逻辑、以及恋爱中的行为，都或多或少受到他们职业背景的影响。</p><p>例如，李明是一位数据分析师，他每天都在处理和分析大量数据，帮助公司做出决策。在工作之外，他的恋爱生活充满了挑战，因为他经常觉得自己过于逻辑，难以理解异性的情感。但事实上，他的技术背景给了他独特的恋爱视角和方法。李明在与女友小芸的互动中，常常能够准确捕捉到她的需求和困惑（逻辑性和细节敏感性）。比如，小芸在谈论她的日常问题时，李明能够通过逻辑分析为她提供解决方案，而不是简单地表达同情。这使得小芸觉得和他在一起非常踏实，诚然女性朋友分享日常问题时候，多数情况下是为了寻求你的安慰，不仅仅是解决问题，对上述情况，我建议男性同胞应该拥抱并且亲吻她，抱着她说：「没关系，我一直都在」。紧接着你觉得对方脾气降下来了，不再抱怨工作和日常了，你就可以趁机杀入你的解决方案，此为上计。还有可能会发生的事：李明在小芸的生日前，使用了简单的网络搜索，找到了她最喜欢的音乐、电影和食物，并据此策划了一场私人的生日惊喜。尽管这只是一个简单的搜索，但它显示了他如何利用自己的技术背景为恋爱增添乐趣。通过这两个简单的例子，我们可以看到，技术并不是与恋爱格格不入的，只要我们能够恰当地运用它，它就可以成为恋爱的有力助手，纯粹依赖安慰的“高情商男性”虽然暂时缓解了状况，但未能从根本上解决问题；而这正是技术人的专长。</p><p>关于“程序员找不到对象”的说法，也是过于笼统的一个判断。与其说是因为他们是程序员，不如说是他们可能在恋爱与社交方面没有投入太多的时间和精力。而这是很多忙碌职业人士都可能会面临的问题，与是否为技术人员无关。诚然，我们的目的并不是为技术人员辩解，而是希望大家能有一个更加公正、客观的看待技术人员在恋爱方面的观念。在接下来的内容中，我们将深入探讨技术人员在恋爱中的优势，以及如何充分利用这些优势。</p><p>我们再来看一个案例。</p><p>李浩和张静是某985大学的学生。李浩就读于计算机科学与技术专业，而张静则是文学与新闻学院的学生。</p><p>李浩的恋爱难题：李浩一直是学校里的技术高手，经常为班级或社团解决技术难题。然而，即使他的专业技能得到了广泛的认可，他在恋爱方面似乎始终无法如愿。</p><p>1）沉迷于技术世界：大部分时间，李浩都沉浸在编程和项目中，无暇关心校园生活中的其他方面。他的社交圈主要是与他有相同兴趣爱好的朋友，很少有与其他专业的学生互动。</p><p>2）沟通的难题：尽管他可以轻松地解释复杂的算法，但在与异性交往时，他经常发现自己难以表达自己的情感。这不是因为他没有情感，而是因为他习惯于逻辑性和直接性的沟通，而缺乏细腻的情感描述。</p><p>3）恋爱的认知：很多人可能都没尝试过这一点，但李浩曾尝试过与其他专业的女生约会，但由于他们对生活的认知差异，两人经常出现观点不合，最终导致感情的破裂。他可能误认为这是因为他是“程序员”而遭遇的问题，而忽视了双方在价值观和兴趣爱好上的差异。</p><p>张静的观察：张静常常看到李浩在图书馆为一个难题而努力，而这使她对李浩产生了兴趣。但她也注意到，李浩很少参与班级或学校的活动，使他缺乏与大多数学生交往的机会。</p><p>张静认为，李浩之所以找不到对象，不仅是因为他是技术人员，更多的是因为他过于专注于自己的兴趣领域，忽视了广泛的社交互动。而这种问题并不仅仅存在于技术人员中，任何过分专注于某一领域的人都可能遭遇相似的困境。</p><p>正所谓旁观者清，我们只是简单举个例子而已。有人说：“这他妈太真实，这不就是我？”肯定也会有人说：“我还不如他。”</p><p>所以我为你们总结了以下教训，请注意，这并不限制性别：</p><ul><li>专业要求高强度投入：技术专业，特别是计算机科学、工程学、物理学等，通常需要学生投入大量时间在实验、项目和学术研究上。因此，这部分学生往往比其他专业的学生更加忙碌，缺乏社交活动的时间。</li><li>同行社交圈子：技术专业学生的社交圈子常常局限于同一个学院或专业，这意味着他们大部分的时间都与同行打交道。这不仅限制了他们接触异性的机会，还可能使他们在与其他专业的学生交往时感到陌生或不适应。</li><li>沟通方式和思维模式：技术专业培养学生的逻辑思维和问题解决能力。这样的培训有时可能导致他们在日常交往中过于直接或逻辑化，忽略了情感交流和直觉，从而造成沟通障碍。</li><li>自我认知偏差：由于社会对“宅男”或“技术宅”的刻板印象，技术专业的学生可能会误认为自己因为专业背景而在恋爱中处于劣势，从而缺乏自信。</li><li>缺乏恋爱技巧：对于许多深陷于技术学习的学生来说，他们可能没有足够的时间和机会学习恋爱中的互动技巧，如何给与关心、如何解读对方的情感等。</li><li>生活习惯和兴趣偏好：技术学生可能更喜欢宅在家里玩游戏、看技术博客或编程，而不是参与校园活动或社交活动。这种生活方式可能使他们错过了很多认识异性的机会。</li></ul><p>……</p><p>不要说这些你都已经中招了。</p>]]></content>
      
      
      <categories>
          
          <category> Love </category>
          
      </categories>
      
      
        <tags>
            
            <tag> life </tag>
            
            <tag> love </tag>
            
        </tags>
      
    </entry>
    
    
    
    <entry>
      <title>Hello World</title>
      <link href="/blog/2023/08/11/hello-world/"/>
      <url>/blog/2023/08/11/hello-world/</url>
      
        <content type="html"><![CDATA[<h2 id="Welcome-to-Wxrkz"><a href="#Welcome-to-Wxrkz" class="headerlink" title="Welcome to Wxrkz!"></a>Welcome to Wxrkz!</h2><p>作为一个刚入门的小白，拥有一个属于自己的博客，我感觉已经非常激动了。</p><p>让我有写博客的念头的原因有以下三点：</p><h4 id="1-作为一个软件开发爱好者，写博客的过程也是一个学习，自我成长的一个过程。方便自己将平常所学所见记录下来，也可以满足我的分享欲哈哈哈哈。技术就是要开源才好玩，自己一个人闷着头，像井底之蛙一样，永远不得长进。三人行，必有我师。"><a href="#1-作为一个软件开发爱好者，写博客的过程也是一个学习，自我成长的一个过程。方便自己将平常所学所见记录下来，也可以满足我的分享欲哈哈哈哈。技术就是要开源才好玩，自己一个人闷着头，像井底之蛙一样，永远不得长进。三人行，必有我师。" class="headerlink" title="1.作为一个软件开发爱好者，写博客的过程也是一个学习，自我成长的一个过程。方便自己将平常所学所见记录下来，也可以满足我的分享欲哈哈哈哈。技术就是要开源才好玩，自己一个人闷着头，像井底之蛙一样，永远不得长进。三人行，必有我师。"></a>1.作为一个软件开发爱好者，写博客的过程也是一个学习，自我成长的一个过程。方便自己将平常所学所见记录下来，也可以满足我的分享欲哈哈哈哈。技术就是要开源才好玩，自己一个人闷着头，像井底之蛙一样，永远不得长进。三人行，必有我师。</h4><h4 id="2-自己想记录一点东西，作为自己成长的一个记录。大多也就是我自己随笔写写，分享一些文章或者分享自己学习编程的一些知识。"><a href="#2-自己想记录一点东西，作为自己成长的一个记录。大多也就是我自己随笔写写，分享一些文章或者分享自己学习编程的一些知识。" class="headerlink" title="2.自己想记录一点东西，作为自己成长的一个记录。大多也就是我自己随笔写写，分享一些文章或者分享自己学习编程的一些知识。"></a>2.自己想记录一点东西，作为自己成长的一个记录。大多也就是我自己随笔写写，分享一些文章或者分享自己学习编程的一些知识。</h4><h4 id="3-最重要的是，我热爱编程，编程可谓是一种艺术。我想用博客来时刻告诫自己。最后希望自己能够坚持下来。"><a href="#3-最重要的是，我热爱编程，编程可谓是一种艺术。我想用博客来时刻告诫自己。最后希望自己能够坚持下来。" class="headerlink" title="3.最重要的是，我热爱编程，编程可谓是一种艺术。我想用博客来时刻告诫自己。最后希望自己能够坚持下来。"></a>3.最重要的是，我热爱编程，编程可谓是一种艺术。我想用博客来时刻告诫自己。最后希望自己能够坚持下来。</h4><p>More info WX:wxrkz123 </p>]]></content>
      
      
      
    </entry>
    
    
  
  
</search>
